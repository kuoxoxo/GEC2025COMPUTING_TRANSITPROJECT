<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transit Route Finder</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Leaflet CSS for map styling -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet JS library for interactive maps -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <!-- Main content container -->
    <main class="simple-layout">
        <!-- Map section -->
        <section class="map-section">
            <!-- Map container - Leaflet will render here -->
            <div id="map" style="width: 100%; height: 500px; border-radius: 8px; overflow: hidden;"></div>
            <!-- Lat/Lon display overlay (shows current mouse position on map) -->
            <div id="latlon" class="map-coords">Lat: Lon: </div>
        </section>

        <!-- Terminal section -->
        <section class="terminal-section">
            <div class="terminal-header">
                <h3>GEC2025 C Program Terminal</h3>
                <div class="terminal-buttons">
                    <button id="startBtn" class="btn-primary">Start</button>
                    <button id="restartBtn" class="btn-secondary">Restart</button>
                </div>
            </div>
            <div id="terminal" class="terminal-output"></div>
            <div class="terminal-input-area">
                <input type="text" id="terminalInput" class="terminal-input" placeholder="Enter stop name or ID..." />
                <button id="submitBtn" class="btn-submit">Submit</button>
            </div>
        </section>
    </main>

    <!-- Main JavaScript logic -->
    <script>
        // Wait for DOM to fully load before running code
        document.addEventListener('DOMContentLoaded', function () {
            // ============================================
            // MAP INITIALIZATION
            // ============================================
            // Center on University of Guelph
            const map = L.map('map').setView([43.5322, -80.2230], 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Update lat/lon display on mouse move over map
            const latlonDisplay = document.getElementById('latlon');
            map.on('mousemove', function (e) {
                const lat = e.latlng.lat.toFixed(4);
                const lon = e.latlng.lng.toFixed(4);
                latlonDisplay.textContent = `Lat: ${lat}   Lon: ${lon}`;
            });

            // ============================================
            // TERMINAL FUNCTIONALITY
            // ============================================
            const terminal = document.getElementById('terminal');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const terminalInput = document.getElementById('terminalInput');
            const submitBtn = document.getElementById('submitBtn');
            let isRunning = false;
            let stopsData = [];
            let inputState = null; // 'waiting_origin' or 'waiting_final'
            let originStop = null;
            let finalStop = null;

            // Add text to terminal with scrolling
            function addTerminalLine(text, isError = false) {
                const line = document.createElement('div');
                line.textContent = text;
                if (isError) line.style.color = '#ff6b6b';
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
            }

            // Robust CSV parser (handles CRLF and quoted fields)
            // Returns array of objects keyed by header names
            function parseCSV(csvText) {
                // Normalize line endings
                const text = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

                // Lightweight RFC4180 parser
                const rows = [];
                let cur = '';
                let row = [];
                let inQuotes = false;
                for (let i = 0; i < text.length; i++) {
                    const ch = text[i];
                    if (ch === '"') {
                        if (inQuotes && text[i + 1] === '"') {
                            // Escaped quote
                            cur += '"';
                            i++; // skip next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (ch === ',' && !inQuotes) {
                        row.push(cur);
                        cur = '';
                    } else if (ch === '\n' && !inQuotes) {
                        row.push(cur);
                        cur = '';
                        rows.push(row);
                        row = [];
                    } else {
                        cur += ch;
                    }
                }
                // push last field/row if any
                if (cur !== '' || row.length > 0) {
                    row.push(cur);
                    rows.push(row);
                }

                if (rows.length === 0) return [];

                const headers = rows[0].map(h => h.trim());
                const data = [];
                for (let r = 1; r < rows.length; r++) {
                    const values = rows[r];
                    // skip empty rows
                    if (values.length === 1 && values[0].trim() === '') continue;
                    const obj = {};
                    for (let c = 0; c < headers.length; c++) {
                        obj[headers[c]] = (values[c] !== undefined) ? values[c].trim() : '';
                    }
                    data.push(obj);
                }
                return data;
            }

            // Load stops CSV
            async function loadStopsData() {
                try {
                    const response = await fetch('../csv_files/stops.csv');
                    const csvText = await response.text();

                    // Diagnostics: show raw size and approximate line count
                    const rawBytes = new Blob([csvText]).size;
                    const newlineCount = (csvText.match(/\n/g) || []).length;
                    addTerminalLine(`stops.csv: ${rawBytes} bytes, ~${newlineCount + 1} lines (including header)`);

                    // Preview first/last 2 lines for verification
                    const previewLines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                    addTerminalLine(`Preview first line: ${previewLines[0] || ''}`);
                    addTerminalLine(`Preview second line: ${previewLines[1] || ''}`);
                    addTerminalLine(`Preview last line: ${previewLines[previewLines.length - 1] || ''}`);

                    stopsData = parseCSV(csvText);
                    return true;
                } catch (err) {
                    addTerminalLine(`Error loading stops.csv: ${err.message}`, true);
                    return false;
                }
            }

            // Load routes CSV (diagnostics similar to stops)
            async function loadRoutesData() {
                try {
                    const response = await fetch('../csv_files/routes.csv');
                    const csvText = await response.text();

                    const rawBytes = new Blob([csvText]).size;
                    const newlineCount = (csvText.match(/\n/g) || []).length;
                    addTerminalLine(`routes.csv: ${rawBytes} bytes, ~${newlineCount + 1} lines (including header)`);

                    const previewLines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                    addTerminalLine(`routes preview first: ${previewLines[0] || ''}`);
                    addTerminalLine(`routes preview second: ${previewLines[1] || ''}`);
                    addTerminalLine(`routes preview last: ${previewLines[previewLines.length - 1] || ''}`);

                    const routesData = parseCSV(csvText);
                    addTerminalLine(`Parsed ${routesData.length} routes`);
                    return routesData;
                } catch (err) {
                    addTerminalLine(`Error loading routes.csv: ${err.message}`, true);
                    return null;
                }
            }

            // Find stop by name or ID
            function findStop(query) {
                if (!query) return null;

                const queryLower = query.toLowerCase();

                // Exact match on stop_id
                let found = stopsData.find(stop => stop.stop_id === query);
                if (found) return found;

                // Substring match on stop_name (case-insensitive)
                found = stopsData.find(stop =>
                    stop.stop_name && stop.stop_name.toLowerCase().includes(queryLower)
                );
                return found;
            }

            // Display stop details
            function displayStopInfo(label, stop) {
                addTerminalLine(`\n${label}:`);
                if (stop) {
                    addTerminalLine(`  ID: ${stop.stop_id}`);
                    addTerminalLine(`  Name: ${stop.stop_name}`);
                    if (stop.stop_lat && stop.stop_lon) {
                        addTerminalLine(`  Location: ${stop.stop_lat}, ${stop.stop_lon}`);
                    }
                } else {
                    addTerminalLine('  No matching stop found', true);
                }
            }

            // Start the program
            async function startProgram() {
                if (isRunning) return;

                terminal.innerHTML = '';
                addTerminalLine('$ gec2025 - GTFS Stop Lookup Program\n');
                startBtn.disabled = true;
                restartBtn.disabled = true;
                terminalInput.disabled = false;
                submitBtn.disabled = false;
                isRunning = true;
                inputState = 'waiting_origin';
                originStop = null;
                finalStop = null;

                try {
                    // Load the stops data
                    addTerminalLine('Loading stops.csv...');
                    const loaded = await loadStopsData();

                    if (!loaded || stopsData.length === 0) {
                        addTerminalLine('Error: Could not load stops data', true);
                        startBtn.disabled = false;
                        restartBtn.disabled = false;
                        terminalInput.disabled = true;
                        submitBtn.disabled = true;
                        isRunning = false;
                        inputState = null;
                        return;
                    }

                    addTerminalLine(`Loaded ${stopsData.length} stops\n`);
                    // Also load and report routes.csv diagnostics
                    const routes = await loadRoutesData();
                    if (routes) addTerminalLine(`Loaded ${routes.length} routes\n`);
                    addTerminalLine('Enter origin stop name or stop_id:');
                    terminalInput.focus();
                } catch (err) {
                    addTerminalLine(`Error: ${err.message}`, true);
                    startBtn.disabled = false;
                    restartBtn.disabled = false;
                    terminalInput.disabled = true;
                    submitBtn.disabled = true;
                    isRunning = false;
                    inputState = null;
                }
            }

            // Handle user input submission
            function handleUserInput() {
                const input = terminalInput.value.trim();
                if (!input) return;

                // Echo the input to terminal
                addTerminalLine(input);
                terminalInput.value = '';

                if (inputState === 'waiting_origin') {
                    originStop = findStop(input);
                    displayStopInfo('Origin Stop', originStop);
                    addTerminalLine('\nEnter final stop name or stop_id:');
                    inputState = 'waiting_final';
                    terminalInput.focus();
                } else if (inputState === 'waiting_final') {
                    finalStop = findStop(input);
                    displayStopInfo('Final Stop', finalStop);

                    // Program complete
                    addTerminalLine('\n$ Program completed successfully');

                    // Disable input
                    terminalInput.disabled = true;
                    submitBtn.disabled = true;
                    startBtn.disabled = false;
                    restartBtn.disabled = false;
                    isRunning = false;
                    inputState = null;
                }
            }

            // Restart the program
            function restartProgram() {
                startProgram();
            }

            // Event listeners
            startBtn.addEventListener('click', startProgram);
            restartBtn.addEventListener('click', restartProgram);
            submitBtn.addEventListener('click', handleUserInput);
            terminalInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') handleUserInput();
            });

            // Initial state
            terminalInput.disabled = true;
            submitBtn.disabled = true;
            addTerminalLine('Ready. Click "Start" to run the GEC2025 C program.');
            addTerminalLine('This simulates the C program in the browser.');
        });
    </script>
</body>

</html>