<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Guelph GTFS Map</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 16px;
        }

        #map {
            width: 100%;
            height: 520px;
            border-radius: 8px;
        }

        .controls {
            max-width: 900px;
            margin-bottom: 12px;
            display: grid;
            gap: 8px;
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        label {
            font-weight: 600;
            margin-right: 6px;
        }

        select,
        input[type="text"] {
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #ccc;
            min-width: 220px;
        }

        button {
            padding: 8px 10px;
            border-radius: 6px;
            background: #35424a;
            color: #fff;
            border: none;
            cursor: pointer;
        }

        button.secondary {
            background: #e6e6e6;
            color: #222;
        }

        pre.info {
            background: #f7f7f7;
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>Guelph GTFS Map — select start & end</h1>

    <div class="controls">
        <div>
            <strong>CSV files</strong> — upload to override server files (stops.csv & stop_times.csv required)
        </div>
        <div class="row">
            <input id="stopsFile" type="file" accept=".csv" />
            <input id="stopTimesFile" type="file" accept=".csv" />
            <button id="loadBtn">Load CSVs</button>
            <button id="fetchBtn" class="secondary">Load from ./csv_files (server)</button>
        </div>

        <div>
            <strong>Choose locations</strong>
        </div>

        <div class="row">
            <label for="startSelect">Start</label>
            <select id="startSelect"></select>

            <label for="endSelect">End</label>
            <select id="endSelect"></select>
        </div>

        <div class="row">
            <label for="startText">Or start (name/id)</label>
            <input id="startText" type="text" placeholder="e.g. Macdonald Hall or S1" />
            <label for="endText">Or end (name/id)</label>
            <input id="endText" type="text" placeholder="e.g. University Centre or S3" />
            <button id="routeBtn">Get Route</button>
            <button id="clearBtn" class="secondary">Clear Map</button>
        </div>

        <div>
            <div id="status" class="info">Status: idle</div>
        </div>
    </div>

    <div id="map"></div>

    <script>
        /* Minimal GTFS route viewer:
           - Accepts uploaded stops.csv and stop_times.csv (or falls back to ./csv_files/)
           - Populates start/end selects
           - Finds a trip that contains both stops in-order and draws that segment on the Leaflet map
        */

        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let polyLayer = null;
        let markerLayers = [];

        const stops = {};          // stop_id -> {stop_id, stop_name, lat, lon}
        const stopsList = [];      // array of stops
        const stopTimesByTrip = {}; // trip_id -> [{stop_id, stop_sequence}, ...]

        let stopsFileText = null, stopTimesFileText = null;

        const stopsFile = document.getElementById('stopsFile');
        const stopTimesFile = document.getElementById('stopTimesFile');
        const loadBtn = document.getElementById('loadBtn');
        const fetchBtn = document.getElementById('fetchBtn');
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const startText = document.getElementById('startText');
        const endText = document.getElementById('endText');
        const routeBtn = document.getElementById('routeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusEl = document.getElementById('status');

        /* file readers */
        function readLocalFile(file, cb) {
            if (!file) { cb(null); return; }
            const fr = new FileReader();
            fr.onload = () => cb(fr.result);
            fr.onerror = () => cb(null);
            fr.readAsText(file, 'utf-8');
        }
        stopsFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopsFileText = txt; status('stops file loaded'); }));
        stopTimesFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopTimesFileText = txt; status('stop_times file loaded'); }));

        /* status helper */
        function status(msg) { statusEl.textContent = 'Status: ' + msg; }

        /* robust CSV parser (handles BOM, quoted fields, common delimiters) */
        function parseCSV(text) {
            if (!text) return [];
            if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const first = text.split('\n').find(l => l.trim().length > 0) || '';
            const counts = { ',': (first.match(/,/g) || []).length, ';': (first.match(/;/g) || []).length, '\t': (first.match(/\t/g) || []).length };
            const delim = (counts[';'] > counts[',']) ? ';' : ((counts['\t'] > counts[',']) ? '\t' : ',');
            const rows = []; let cur = [], field = '', inQ = false;
            for (let i = 0; i < text.length; i++) {
                const ch = text[i];
                if (inQ) {
                    if (ch === '"') { if (text[i + 1] === '"') { field += '"'; i++; } else inQ = false; }
                    else field += ch;
                } else {
                    if (ch === '"') inQ = true;
                    else if (ch === delim) { cur.push(field); field = ''; }
                    else if (ch === '\n') { cur.push(field); rows.push(cur); cur = []; field = ''; }
                    else field += ch;
                }
            }
            if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }
            const cleaned = rows.map(r => r.map(f => (f === undefined ? '' : String(f).trim())));
            while (cleaned.length && cleaned[cleaned.length - 1].every(c => c === '')) cleaned.pop();
            return cleaned;
        }

        /* fetch helper */
        async function fetchCSV(path) {
            const res = await fetch(path);
            if (!res.ok) throw new Error('HTTP ' + res.status);
            const txt = await res.text();
            return parseCSV(txt);
        }

        /* load GTFS data (uploaded preferred, otherwise from ./csv_files/) */
        async function loadGTFS() {
            try {
                status('loading CSVs...');
                const stopsRows = stopsFileText ? parseCSV(stopsFileText) : await fetchCSV('./csv_files/stops.csv');
                const stopTimesRows = stopTimesFileText ? parseCSV(stopTimesFileText) : await fetchCSV('./csv_files/stop_times.csv');

                // reset
                Object.keys(stops).forEach(k => delete stops[k]);
                stopsList.length = 0;
                Object.keys(stopTimesByTrip).forEach(k => delete stopTimesByTrip[k]);

                if (!stopsRows || stopsRows.length < 1) throw new Error('stops.csv missing or empty');

                const hdrStops = stopsRows[0].map(h => (h || '').toString().trim().toLowerCase());
                let i_id = hdrStops.indexOf('stop_id');
                let i_name = hdrStops.indexOf('stop_name');
                let i_lat = hdrStops.indexOf('stop_lat');
                let i_lon = hdrStops.indexOf('stop_lon');
                if (i_id === -1) i_id = hdrStops.indexOf('id');
                if (i_name === -1) i_name = hdrStops.indexOf('name');
                if (i_lat === -1) i_lat = hdrStops.indexOf('lat');
                if (i_lon === -1) i_lon = hdrStops.indexOf('lon');

                // parse stops rows
                for (let r = 1; r < stopsRows.length; r++) {
                    const row = stopsRows[r];
                    if (!row) continue;
                    const id = (i_id >= 0 && i_id < row.length) ? String(row[i_id]).trim() : '';
                    const name = (i_name >= 0 && i_name < row.length) ? String(row[i_name]).trim() : id;
                    const lat = (i_lat >= 0 && i_lat < row.length) ? parseFloat(String(row[i_lat]).trim()) : NaN;
                    const lon = (i_lon >= 0 && i_lon < row.length) ? parseFloat(String(row[i_lon]).trim()) : NaN;
                    if (!id || isNaN(lat) || isNaN(lon)) continue;
                    const s = { stop_id: id, stop_name: name || id, lat, lon };
                    stops[id] = s; stopsList.push(s);
                }

                // parse stop_times
                if (stopTimesRows && stopTimesRows.length > 0) {
                    const hdrTimes = stopTimesRows[0].map(h => (h || '').toString().trim().toLowerCase());
                    const i_trip = hdrTimes.indexOf('trip_id') !== -1 ? hdrTimes.indexOf('trip_id') : hdrTimes.indexOf('trip');
                    const i_stop = hdrTimes.indexOf('stop_id') !== -1 ? hdrTimes.indexOf('stop_id') : hdrTimes.indexOf('stop');
                    let i_seq = hdrTimes.indexOf('stop_sequence');
                    if (i_seq === -1) { i_seq = hdrTimes.indexOf('stoporder'); if (i_seq === -1) i_seq = hdrTimes.indexOf('sequence'); }
                    for (let r = 1; r < stopTimesRows.length; r++) {
                        const row = stopTimesRows[r];
                        if (!row) continue;
                        const tid = (i_trip >= 0 && i_trip < row.length) ? String(row[i_trip]).trim() : '';
                        const sid = (i_stop >= 0 && i_stop < row.length) ? String(row[i_stop]).trim() : '';
                        const seq = (i_seq >= 0 && i_seq < row.length) ? parseInt(String(row[i_seq]).trim(), 10) : r;
                        if (!tid || !sid) continue;
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: isNaN(seq) ? r : seq });
                    }
                }

                populateSelects();
                status(`loaded ${stopsList.length} stops, ${Object.keys(stopTimesByTrip).length} trips`);
            } catch (err) {
                console.error(err);
                status('load error: ' + (err && err.message ? err.message : err));
                alert('CSV load failed: ' + (err && err.message ? err.message : err));
            }
        }

        /* populate selects */
        function populateSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const placeholder = document.createElement('option'); placeholder.value = ''; placeholder.textContent = '-- choose --';
            startSelect.appendChild(placeholder.cloneNode(true));
            endSelect.appendChild(placeholder.cloneNode(true));
            // sort by name for nicer UX
            stopsList.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
            for (const s of stopsList) {
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = `${s.stop_name} (${s.stop_id})`;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            }
        }

        /* find stop by id or name substring */
        function findStop(query) {
            if (!query) return null;
            query = String(query).trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            return null;
        }

        /* find trip sequence containing origin->final (in-order) */
        function findTripSequence(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        /* draw sequence */
        function drawSequence(seq) {
            clearMap();
            if (!seq || seq.length === 0) return;
            const latlngs = seq.map(s => [s.lat, s.lon]);
            polyLayer = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            seq.forEach((s, i) => {
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} (${s.stop_id})`);
                markerLayers.push(m);
            });
            try { map.fitBounds(polyLayer.getBounds(), { padding: [20, 20] }); } catch (e) { }
            // compute straight-line distance
            let dist = 0;
            for (let i = 0; i < seq.length - 1; i++) dist += haversine(seq[i].lat, seq[i].lon, seq[i + 1].lat, seq[i + 1].lon);
            status(`plotted ${seq.length} stops — distance ≈ ${dist.toFixed(2)} km`);
        }

        /* clear */
        function clearMap() {
            if (polyLayer) { map.removeLayer(polyLayer); polyLayer = null; }
            markerLayers.forEach(m => map.removeLayer(m)); markerLayers = [];
            status('cleared map');
        }

        /* haversine km */
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        /* main route action */
        function handleRoute() {
            // prefer selects if chosen
            const sId = startSelect.value || null;
            const eId = endSelect.value || null;
            let origin = sId ? stops[sId] : findStop(startText.value);
            let final = eId ? stops[eId] : findStop(endText.value);

            if (!origin || !final) { alert('Could not resolve both origin and final stops. Load CSVs and try again.'); return; }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            const seq = findTripSequence(origin.stop_id, final.stop_id);
            if (!seq) {
                // fallback: direct line
                if (!confirm('No trip contains both stops in order. Draw direct connection instead?')) return;
                drawSequence([origin, final]);
                return;
            }
            drawSequence(seq);
        }

        /* UI wiring */
        loadBtn.addEventListener('click', loadGTFS);
        fetchBtn.addEventListener('click', () => { stopsFileText = null; stopTimesFileText = null; loadGTFS(); });
        routeBtn.addEventListener('click', handleRoute);
        clearBtn.addEventListener('click', clearMap);

        /* initial attempt to load server CSVs */
        loadGTFS();
    </script>
</body>

</html>