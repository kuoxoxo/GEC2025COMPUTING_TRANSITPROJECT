<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transit Route Finder</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Leaflet CSS for map styling -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet JS library for interactive maps -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <!-- Main content container -->
    <main class="simple-layout">
        <!-- Map section -->
        <section class="map-section">
            <!-- Map container - Leaflet will render here -->
            <div id="map" style="width: 100%; height: 500px; border-radius: 8px; overflow: hidden;"></div>
            <!-- Lat/Lon display overlay (shows current mouse position on map) -->
            <div id="latlon" class="map-coords">Lat: Lon: </div>
        </section>

        <!-- Terminal section -->
        <section class="terminal-section">
            <div class="terminal-header">
                <h3>GEC2025 C Program Terminal</h3>
                <div class="terminal-buttons">
                    <button id="startBtn" class="btn-primary">Start</button>
                    <button id="nativeBtn" class="btn-primary">Run Native</button>
                    <button id="restartBtn" class="btn-secondary">Restart</button>
                </div>
            </div>
            <div id="terminal" class="terminal-output"></div>
            <div class="terminal-input-area">
                <input type="text" id="terminalInput" class="terminal-input" placeholder="Enter stop name or ID..." />
                <button id="submitBtn" class="btn-submit">Submit</button>
            </div>
        </section>
    </main>

    <!-- Main JavaScript logic -->
    <script>
        // Wait for DOM to fully load before running code
        document.addEventListener('DOMContentLoaded', function () {
            // ============================================
            // MAP INITIALIZATION
            // ============================================
            // Center on University of Guelph
            const map = L.map('map').setView([43.5322, -80.2230], 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            // Update lat/lon display on mouse move over map
            const latlonDisplay = document.getElementById('latlon');
            map.on('mousemove', function (e) {
                const lat = e.latlng.lat.toFixed(4);
                const lon = e.latlng.lng.toFixed(4);
                latlonDisplay.textContent = `Lat: ${lat}   Lon: ${lon}`;
            });

            // ============================================
            // TERMINAL FUNCTIONALITY
            // ============================================
            const terminal = document.getElementById('terminal');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const terminalInput = document.getElementById('terminalInput');
            const submitBtn = document.getElementById('submitBtn');
            let isRunning = false;
            let stopsData = [];
            let inputState = null; // 'waiting_origin' or 'waiting_final'
            let originStop = null;
            let finalStop = null;

            // Add text to terminal with scrolling
            function addTerminalLine(text, isError = false) {
                const line = document.createElement('div');
                line.textContent = text;
                if (isError) line.style.color = '#ff6b6b';
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
            }

            // Add a prompt that will be echoed on the same line when the user
            // submits their input, to mimic terminal behavior.
            let _lastPromptEchoSpan = null;
            function addTerminalPrompt(promptText) {
                const line = document.createElement('div');
                const promptSpan = document.createElement('span');
                promptSpan.textContent = promptText;
                const echoSpan = document.createElement('span');
                echoSpan.textContent = '';
                line.appendChild(promptSpan);
                line.appendChild(echoSpan);
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                _lastPromptEchoSpan = echoSpan;
            }

            // Robust CSV parser (handles CRLF and quoted fields)
            // Returns array of objects keyed by header names
            function parseCSV(csvText) {
                // Normalize line endings
                const text = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

                // Lightweight RFC4180 parser
                const rows = [];
                let cur = '';
                let row = [];
                let inQuotes = false;
                for (let i = 0; i < text.length; i++) {
                    const ch = text[i];
                    if (ch === '"') {
                        if (inQuotes && text[i + 1] === '"') {
                            // Escaped quote
                            cur += '"';
                            i++; // skip next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (ch === ',' && !inQuotes) {
                        row.push(cur);
                        cur = '';
                    } else if (ch === '\n' && !inQuotes) {
                        row.push(cur);
                        cur = '';
                        rows.push(row);
                        row = [];
                    } else {
                        cur += ch;
                    }
                }
                // push last field/row if any
                if (cur !== '' || row.length > 0) {
                    row.push(cur);
                    rows.push(row);
                }

                if (rows.length === 0) return [];

                // Trim BOM from first header if present
                if (rows[0].length > 0 && rows[0][0].charCodeAt(0) === 0xFEFF) {
                    rows[0][0] = rows[0][0].slice(1);
                }

                const headers = rows[0].map(h => h.trim());
                const data = [];
                for (let r = 1; r < rows.length; r++) {
                    const values = rows[r];
                    // skip empty rows
                    if (values.length === 1 && values[0].trim() === '') continue;
                    const obj = {};
                    for (let c = 0; c < headers.length; c++) {
                        obj[headers[c]] = (values[c] !== undefined) ? values[c].trim() : '';
                    }
                    data.push(obj);
                }
                return data;
            }

            // Load stops CSV
            async function loadStopsData() {
                try {
                    const response = await fetch('../csv_files/stops.csv');
                    const csvText = await response.text();

                    // Diagnostics: show raw size and approximate line count
                    const rawBytes = new Blob([csvText]).size;
                    const newlineCount = (csvText.match(/\n/g) || []).length;
                    addTerminalLine(`stops.csv: ${rawBytes} bytes, ~${newlineCount + 1} lines (including header)`);

                    // Preview first/last 2 lines for verification
                    const previewLines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                    addTerminalLine(`Preview first line: ${previewLines[0] || ''}`);
                    addTerminalLine(`Preview second line: ${previewLines[1] || ''}`);
                    addTerminalLine(`Preview last line: ${previewLines[previewLines.length - 1] || ''}`);

                    stopsData = parseCSV(csvText);
                    return true;
                } catch (err) {
                    addTerminalLine(`Error loading stops.csv: ${err.message}`, true);
                    return false;
                }
            }

            // Load stop_times and trips (used to build ordered stop sequences)
            let stopTimes = []; // {trip_id, stop_id, stop_sequence}
            let trips = []; // {trip_id, route_id}

            async function loadTripsAndStopTimes() {
                try {
                    const [stResp, trResp] = await Promise.all([
                        fetch('../csv_files/stop_times.csv'),
                        fetch('../csv_files/trips.csv')
                    ]);
                    const stText = await stResp.text();
                    const trText = await trResp.text();

                    const stRows = parseCSV(stText);
                    const trRows = parseCSV(trText);

                    // Map stop_times to simplified objects and sort by stop_sequence
                    stopTimes = stRows.map(r => ({
                        trip_id: r.trip_id || '',
                        stop_id: r.stop_id || '',
                        stop_sequence: parseInt(r.stop_sequence || '0', 10)
                    }));

                    trips = trRows.map(r => ({ trip_id: r.trip_id || '', route_id: r.route_id || '' }));

                    // Build an index: trip_id -> ordered list of stop_ids
                    return true;
                } catch (err) {
                    addTerminalLine(`Error loading trips/stop_times: ${err.message}`, true);
                    return false;
                }
            }

            // Build trip -> ordered stop_id arrays
            function buildTripIndex() {
                const tripMap = new Map();
                for (const st of stopTimes) {
                    if (!tripMap.has(st.trip_id)) tripMap.set(st.trip_id, []);
                    tripMap.get(st.trip_id).push(st);
                }
                // sort each trip by stop_sequence and replace with stop_id array
                const tripStops = new Map();
                for (const [trip_id, entries] of tripMap.entries()) {
                    entries.sort((a, b) => a.stop_sequence - b.stop_sequence);
                    tripStops.set(trip_id, entries.map(e => e.stop_id));
                }
                return tripStops;
            }

            // Find a trip that contains origin and final in order
            function findTripContaining(originId, finalId, tripStopsIndex) {
                for (const [trip_id, stopsArr] of tripStopsIndex.entries()) {
                    const i1 = stopsArr.indexOf(originId);
                    const i2 = stopsArr.indexOf(finalId);
                    if (i1 !== -1 && i2 !== -1 && i1 < i2) {
                        return { trip_id, stopsBetween: stopsArr.slice(i1, i2 + 1) };
                    }
                }
                return null;
            }

            // Draw polyline through list of stop_ids
            let currentPolyline = null;
            function drawPathThroughStops(stopIds) {
                const latlngs = [];
                for (const sid of stopIds) {
                    const s = stopsData.find(x => x.stop_id === sid);
                    if (s && s.stop_lat && s.stop_lon) {
                        latlngs.push([parseFloat(s.stop_lat), parseFloat(s.stop_lon)]);
                    }
                }
                if (latlngs.length < 2) return false;
                if (currentPolyline) map.removeLayer(currentPolyline);
                currentPolyline = L.polyline(latlngs, { color: 'blue', weight: 4 }).addTo(map);
                map.fitBounds(currentPolyline.getBounds(), { padding: [20, 20] });
                return true;
            }

            // Load routes CSV (diagnostics similar to stops)
            async function loadRoutesData() {
                try {
                    const response = await fetch('../csv_files/routes.csv');
                    const csvText = await response.text();

                    const rawBytes = new Blob([csvText]).size;
                    const newlineCount = (csvText.match(/\n/g) || []).length;
                    addTerminalLine(`routes.csv: ${rawBytes} bytes, ~${newlineCount + 1} lines (including header)`);

                    const previewLines = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
                    addTerminalLine(`routes preview first: ${previewLines[0] || ''}`);
                    addTerminalLine(`routes preview second: ${previewLines[1] || ''}`);
                    addTerminalLine(`routes preview last: ${previewLines[previewLines.length - 1] || ''}`);

                    const routesData = parseCSV(csvText);
                    addTerminalLine(`Parsed ${routesData.length} routes`);
                    return routesData;
                } catch (err) {
                    addTerminalLine(`Error loading routes.csv: ${err.message}`, true);
                    return null;
                }
            }

            // Find stop by name or ID
            function findStop(query) {

                if (!query) return null;

                const queryLower = query.toLowerCase();

                // Exact match on stop_id
                let found = stopsData.find(stop => stop.stop_id === query);
                if (found) return found;

                // Substring match on stop_name (case-insensitive)
                found = stopsData.find(stop =>
                    stop.stop_name && stop.stop_name.toLowerCase().includes(queryLower)
                );
                return found;
            }

            // Display stop details
            function displayStopInfo(label, stop, query) {
                addTerminalLine('');
                addTerminalLine(`${label}:`);
                if (stop) {
                    addTerminalLine(`Found stop: id=${stop.stop_id} name=${stop.stop_name}`);
                } else {
                    addTerminalLine(`No matching stop found for '${query}'.`, true);
                }
            }

            // Start the program
            async function startProgram() {
                if (isRunning) return;

                terminal.innerHTML = '';
                addTerminalLine('$ gec2025 - GTFS Stop Lookup Program\n');
                startBtn.disabled = true;
                restartBtn.disabled = true;
                terminalInput.disabled = false;
                submitBtn.disabled = false;
                isRunning = true;
                inputState = 'waiting_origin';
                originStop = null;
                finalStop = null;

                try {
                    // Load the stops data
                    addTerminalLine('Loading stops.csv...');
                    const loaded = await loadStopsData();

                    if (!loaded || stopsData.length === 0) {
                        addTerminalLine('Error: Could not load stops data', true);
                        startBtn.disabled = false;
                        restartBtn.disabled = false;
                        terminalInput.disabled = true;
                        submitBtn.disabled = true;
                        isRunning = false;
                        inputState = null;
                        return;
                    }

                    addTerminalLine(`Loaded ${stopsData.length} stops\n`);
                    // Also load and report routes.csv diagnostics
                    const routes = await loadRoutesData();
                    if (routes) addTerminalLine(`Loaded ${routes.length} routes\n`);
                    // Match C program prompt
                    addTerminalPrompt('Enter origin stop name or stop_id: ');
                    terminalInput.focus();
                } catch (err) {
                    addTerminalLine(`Error: ${err.message}`, true);
                    startBtn.disabled = false;
                    restartBtn.disabled = false;
                    terminalInput.disabled = true;
                    submitBtn.disabled = true;
                    isRunning = false;
                    inputState = null;
                }
            }

            // Handle user input submission
            function handleUserInput() {
                const input = terminalInput.value.trim();
                if (!input) return;

                // Echo input on the same prompt line (like a terminal)
                if (_lastPromptEchoSpan) {
                    _lastPromptEchoSpan.textContent = input;
                    _lastPromptEchoSpan = null;
                } else {
                    addTerminalLine(input);
                }
                terminalInput.value = '';

                if (inputState === 'waiting_origin') {
                    originStop = findStop(input);
                    displayStopInfo('Origin Stop', originStop, input);
                    addTerminalPrompt('Enter final stop name or stop_id: ');
                    inputState = 'waiting_final';
                    terminalInput.focus();
                } else if (inputState === 'waiting_final') {
                    finalStop = findStop(input);
                    displayStopInfo('Final Stop', finalStop, input);

                    // Program complete
                    addTerminalLine('');
                    addTerminalLine('$ Program completed successfully');

                    // Try to load stop_times/trips and draw path
                    (async () => {
                        const loaded = await loadTripsAndStopTimes();
                        if (loaded) {
                            const tripIndex = buildTripIndex();
                            const oid = originStop ? originStop.stop_id : null;
                            const fid = finalStop ? finalStop.stop_id : null;
                            if (oid && fid) {
                                const found = findTripContaining(oid, fid, tripIndex);
                                if (found) {
                                    addTerminalLine(`Drawing path for trip ${found.trip_id} through ${found.stopsBetween.length} stops`);
                                    const ok = drawPathThroughStops(found.stopsBetween);
                                    if (!ok) addTerminalLine('Not enough coordinates to draw path', true);
                                } else {
                                    addTerminalLine('No trip found that contains both stops in order', true);
                                }
                            }
                        }
                    })();

                    // Disable input
                    terminalInput.disabled = true;
                    submitBtn.disabled = true;
                    startBtn.disabled = false;
                    restartBtn.disabled = false;
                    isRunning = false;
                    inputState = null;
                }
            }

            // Restart the program
            function restartProgram() {
                startProgram();
            }

            // (Native runner removed from UI)

            // Run the native compiled program via local server
            async function runNativeProgram(inputLines) {
                // inputLines should be an array of lines to send as stdin
                try {
                    addTerminalLine('\nStarting native execution (server) ...');
                    const body = { input: inputLines.join('\n') + '\n' };
                    const resp = await fetch('http://localhost:3000/run', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });

                    if (!resp.ok && resp.status !== 200) {
                        addTerminalLine(`Server returned ${resp.status} ${resp.statusText}`, true);
                        return false;
                    }

                    // Stream response body
                    const reader = resp.body.getReader();
                    const decoder = new TextDecoder();
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = decoder.decode(value);
                        addTerminalLine(chunk);
                    }
                    addTerminalLine('\nNative run complete');
                    return true;
                } catch (err) {
                    addTerminalLine(`Error running native program: ${err.message}`, true);
                    return false;
                }
            }

            // Event listeners
            startBtn.addEventListener('click', startProgram);
            document.getElementById('nativeBtn').addEventListener('click', async function () {
                // Run the native program via server and draw path after completion
                terminal.innerHTML = '';
                addTerminalLine('$ Running native gec2025.exe');

                // Ensure stops loaded
                addTerminalLine('Loading stops.csv...');
                const loaded = await loadStopsData();
                if (!loaded || stopsData.length === 0) {
                    addTerminalLine('Error: Could not load stops data', true);
                    return;
                }

                // Prompt for origin/final
                const origin = prompt('Enter origin stop name or stop_id:');
                if (!origin) { addTerminalLine('No origin provided. Cancelled.', true); return; }
                const final = prompt('Enter final stop name or stop_id:');
                if (!final) { addTerminalLine('No final provided. Cancelled.', true); return; }

                // Echo prompts into terminal like program would
                addTerminalPrompt('Enter origin stop name or stop_id: ');
                if (_lastPromptEchoSpan) { _lastPromptEchoSpan.textContent = origin; _lastPromptEchoSpan = null; }
                addTerminalLine('Origin Stop:');
                const oStop = findStop(origin);
                if (oStop) addTerminalLine(`Found stop: id=${oStop.stop_id} name=${oStop.stop_name}`);
                else addTerminalLine(`No matching stop found for '${origin}'.`, true);

                addTerminalPrompt('Enter final stop name or stop_id: ');
                if (_lastPromptEchoSpan) { _lastPromptEchoSpan.textContent = final; _lastPromptEchoSpan = null; }
                addTerminalLine('Final Stop:');
                const fStop = findStop(final);
                if (fStop) addTerminalLine(`Found stop: id=${fStop.stop_id} name=${fStop.stop_name}`);
                else addTerminalLine(`No matching stop found for '${final}'.`, true);

                // Run native program on server (streams output to terminal)
                await runNativeProgram([origin, final]);

                // Attempt to draw path
                const loaded2 = await loadTripsAndStopTimes();
                if (loaded2) {
                    const tripIndex = buildTripIndex();
                    const oid = oStop ? oStop.stop_id : null;
                    const fid = fStop ? fStop.stop_id : null;
                    if (oid && fid) {
                        const found = findTripContaining(oid, fid, tripIndex);
                        if (found) {
                            addTerminalLine(`Drawing path for trip ${found.trip_id} through ${found.stopsBetween.length} stops`);
                            const ok = drawPathThroughStops(found.stopsBetween);
                            if (!ok) addTerminalLine('Not enough coordinates to draw path', true);
                        } else {
                            addTerminalLine('No trip found that contains both stops in order', true);
                        }
                    }
                }
            });
            restartBtn.addEventListener('click', restartProgram);
            submitBtn.addEventListener('click', handleUserInput);
            terminalInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') handleUserInput();
            });

            // Initial state
            terminalInput.disabled = true;
            submitBtn.disabled = true;
            addTerminalLine('Ready. Click "Start" to run the GEC2025 C program.');
            addTerminalLine('This simulates the C program in the browser.');
        });
    </script>
</body>

</html>