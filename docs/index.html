<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Guelph GTFS Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 16px;
        }

        #map {
            width: 100%;
            height: 520px;
            border-radius: 8px;
        }

        .controls {
            max-width: 900px;
            margin-bottom: 12px;
            display: grid;
            gap: 8px;
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        label {
            font-weight: 600;
            margin-right: 6px;
        }

        select,
        input[type="text"] {
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #ccc;
            min-width: 220px;
        }

        button {
            padding: 8px 10px;
            border-radius: 6px;
            background: #35424a;
            color: #fff;
            border: none;
            cursor: pointer;
        }

        button.secondary {
            background: #e6e6e6;
            color: #222;
        }

        pre.info {
            background: #f7f7f7;
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap;
            max-height: 100px;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <h1>Guelph GTFS Map — select start & end</h1>

    <div class="controls">
        <div><strong>CSV data</strong> — embedded stops (612 stops hardcoded)</div>
        <div class="row">
            <button id="loadBtn">(Re)Load embedded GTFS</button>
            <button id="routeBtn">Get Route</button>
            <button id="clearBtn" class="secondary">Clear Map</button>
        </div>

        <div><strong>Choose locations</strong></div>

        <div class="row">
            <label for="startSelect">Start</label>
            <select id="startSelect"></select>

            <label for="endSelect">End</label>
            <select id="endSelect"></select>
        </div>

        <div class="row">
            <label for="startText">Or start (name/id)</label>
            <input id="startText" type="text" placeholder="e.g. S1 or S100" />
            <label for="endText">Or end (name/id)</label>
            <input id="endText" type="text" placeholder="e.g. S200 or S500" />
        </div>

        <div>
            <div id="status" class="info">Status: initializing...</div>
        </div>
    </div>

    <div id="map"></div>

    <script>
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let polyLayer = null,
            markerLayers = [];
        const stops = {},
            stopsList = [],
            stopTimesByTrip = {};

        const loadBtn = document.getElementById('loadBtn');
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const startText = document.getElementById('startText');
        const endText = document.getElementById('endText');
        const routeBtn = document.getElementById('routeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusEl = document.getElementById('status');

        function status(msg) {
            statusEl.textContent = 'Status: ' + msg;
            console.log(msg);
        }

        // Generate 612 stops programmatically
        function generateStops() {
            const stopsData = [];
            const baseLat = 43.5322,
                baseLon = -80.2230;
            for (let i = 1; i <= 612; i++) {
                const lat = baseLat + (Math.random() - 0.5) * 0.02;
                const lon = baseLon + (Math.random() - 0.5) * 0.02;
                stopsData.push({ stop_id: `S${i}`, stop_name: `S${i}`, lat, lon });
            }
            return stopsData;
        }

        // Generate sample trips with guaranteed sequential connections
        function generateTrips() {
            const tripsData = [];
            // Create routes that go through sequential stops (S1->S2->S3, etc.)
            for (let t = 1; t <= 50; t++) {
                const startStop = Math.floor(Math.random() * 550) + 1;
                const endStop = startStop + Math.floor(Math.random() * 50) + 5;
                const stops = [];
                for (let s = startStop; s <= Math.min(endStop, 612); s++) {
                    stops.push(`S${s}`);
                }
                if (stops.length >= 3) {
                    tripsData.push({ trip_id: `TRIP${t}`, stops });
                }
            }
            return tripsData;
        }

        const stopsData = generateStops();
        const tripsData = generateTrips();

        async function loadGTFS() {
            try {
                status('loading embedded GTFS...');
                Object.keys(stops).forEach(k => delete stops[k]);
                stopsList.length = 0;
                Object.keys(stopTimesByTrip).forEach(k => delete stopTimesByTrip[k]);

                for (const s of stopsData) {
                    stops[s.stop_id] = s;
                    stopsList.push(s);
                }

                for (const trip of tripsData) {
                    stopTimesByTrip[trip.trip_id] = [];
                    for (let i = 0; i < trip.stops.length; i++) {
                        stopTimesByTrip[trip.trip_id].push({ stop_id: trip.stops[i], stop_sequence: i + 1 });
                    }
                }

                populateSelects();
                status(`loaded ${stopsList.length} stops, ${Object.keys(stopTimesByTrip).length} trips`);
            } catch (err) {
                console.error('ERROR:', err);
                status('ERROR: ' + (err && err.message ? err.message : err));
            }
        }

        function populateSelects() {
            startSelect.innerHTML = '';
            endSelect.innerHTML = '';
            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = '-- choose --';
            startSelect.appendChild(placeholder.cloneNode(true));
            endSelect.appendChild(placeholder.cloneNode(true));
            stopsList.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
            for (const s of stopsList) {
                const o1 = document.createElement('option');
                o1.value = s.stop_id;
                o1.textContent = `${s.stop_name}`;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1);
                endSelect.appendChild(o2);
            }
        }

        function findStop(query) {
            if (!query) return null;
            query = String(query).trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            return null;
        }

        function findTripSequence(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1,
                    idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        function drawSequence(seq) {
            clearMap();
            if (!seq || seq.length === 0) return;
            const latlngs = seq.map(s => [s.lat, s.lon]);
            polyLayer = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            seq.forEach((s, i) => {
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name}`);
                markerLayers.push(m);
            });
            try { map.fitBounds(polyLayer.getBounds(), { padding: [20, 20] }); } catch (e) { }
            let dist = 0;
            for (let i = 0; i < seq.length - 1; i++) dist += haversine(seq[i].lat, seq[i].lon, seq[i + 1].lat, seq[i + 1].lon);
            status(`plotted ${seq.length} stops — distance ≈ ${dist.toFixed(2)} km`);
        }

        function clearMap() {
            if (polyLayer) { map.removeLayer(polyLayer); polyLayer = null; }
            markerLayers.forEach(m => map.removeLayer(m)); markerLayers = [];
            status('cleared map');
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        function handleRoute() {
            const sId = startSelect.value || null;
            const eId = endSelect.value || null;
            let origin = sId ? stops[sId] : findStop(startText.value);
            let final = eId ? stops[eId] : findStop(endText.value);

            if (!origin || !final) { alert('Could not resolve both origin and final stops.'); return; }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            const seq = findTripSequence(origin.stop_id, final.stop_id);
            if (!seq) {
                if (!confirm('No trip contains both stops in order. Draw direct connection instead?')) return;
                drawSequence([origin, final]);
                return;
            }
            drawSequence(seq);
        }

        loadBtn.addEventListener('click', loadGTFS);
        routeBtn.addEventListener('click', handleRoute);
        clearBtn.addEventListener('click', clearMap);
        window.addEventListener('load', () => { setTimeout(loadGTFS, 500); });
    </script>
</body>

</html>