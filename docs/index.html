<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transit Route Finder</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <main class="simple-layout">
        <section class="map-section">
            <div id="map" style="width: 100%; height: 500px; border-radius: 8px; overflow: hidden;"></div>
            <div id="latlon" class="map-coords">Lat: Lon: </div>
        </section>

        <section class="terminal-section">
            <div class="terminal-header">
                <h3>GEC2025 C Program Terminal</h3>
                <div class="terminal-buttons">
                    <button id="startBtn" class="btn-primary">Start</button>
                    <button id="restartBtn" class="btn-secondary">Restart</button>
                </div>
            </div>
            <div id="terminal" class="terminal-output"></div>
            <div class="terminal-input-area">
                <input type="text" id="terminalInput" class="terminal-input" placeholder="Enter stop name or ID..." />
                <button id="submitBtn" class="btn-submit">Submit</button>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const map = L.map('map').setView([43.5322, -80.2230], 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);

            const latlonDisplay = document.getElementById('latlon');
            map.on('mousemove', function (e) {
                const lat = e.latlng.lat.toFixed(4);
                const lon = e.latlng.lng.toFixed(4);
                latlonDisplay.textContent = `Lat: ${lat}   Lon: ${lon}`;
            });

            // Terminal elements
            const terminal = document.getElementById('terminal');
            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const terminalInput = document.getElementById('terminalInput');
            const submitBtn = document.getElementById('submitBtn');

            // State
            let isRunning = false;
            let stopsData = [];
            let tripStops = new Map();
            let inputState = null;
            let originStop = null;
            let finalStop = null;
            let currentPolyline = null;
            let currentMarkersGroup = null;
            let currentConnectorLines = [];
            let lastPromptEchoSpan = null;

            function parseCSV(csvText) {
                const text = csvText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                const rows = [];
                let cur = '';
                let row = [];
                let inQuotes = false;

                for (let i = 0; i < text.length; i++) {
                    const ch = text[i];
                    if (ch === '"') {
                        if (inQuotes && text[i + 1] === '"') {
                            cur += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (ch === ',' && !inQuotes) {
                        row.push(cur);
                        cur = '';
                    } else if (ch === '\n' && !inQuotes) {
                        row.push(cur);
                        rows.push(row);
                        row = [];
                        cur = '';
                    } else {
                        cur += ch;
                    }
                }
                if (cur !== '' || row.length > 0) {
                    row.push(cur);
                    rows.push(row);
                }

                if (rows.length === 0) return [];

                if (rows[0].length > 0 && rows[0][0].charCodeAt(0) === 0xFEFF) {
                    rows[0][0] = rows[0][0].slice(1);
                }

                const headers = rows[0].map(h => h.trim());
                const data = [];
                for (let r = 1; r < rows.length; r++) {
                    const values = rows[r];
                    if (values.length === 1 && values[0].trim() === '') continue;
                    const obj = {};
                    for (let c = 0; c < headers.length; c++) {
                        obj[headers[c]] = (values[c] !== undefined) ? values[c].trim() : '';
                    }
                    data.push(obj);
                }
                return data;
            }

            function addTerminalLine(text, isError = false) {
                const line = document.createElement('div');
                line.textContent = text;
                if (isError) line.style.color = '#ff6b6b';
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
            }

            function addTerminalPrompt(promptText) {
                const line = document.createElement('div');
                const promptSpan = document.createElement('span');
                promptSpan.textContent = promptText;
                const echoSpan = document.createElement('span');
                echoSpan.textContent = '';
                line.appendChild(promptSpan);
                line.appendChild(echoSpan);
                terminal.appendChild(line);
                terminal.scrollTop = terminal.scrollHeight;
                lastPromptEchoSpan = echoSpan;
            }

            async function loadStopsData() {
                try {
                    const response = await fetch('../csv_files/stops.csv');
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const csvText = await response.text();
                    stopsData = parseCSV(csvText);
                    return true;
                } catch (err) {
                    addTerminalLine(`Error loading stops.csv: ${err.message}`, true);
                    return false;
                }
            }

            async function loadTripsAndStopTimes() {
                try {
                    const [stResp, trResp] = await Promise.all([
                        fetch('../csv_files/stop_times.csv'),
                        fetch('../csv_files/trips.csv')
                    ]);
                    if (!stResp.ok || !trResp.ok) throw new Error('HTTP error');
                    const stText = await stResp.text();
                    const stRows = parseCSV(stText);

                    const tripMap = new Map();
                    for (const st of stRows) {
                        const trip_id = st.trip_id || '';
                        const stop_id = st.stop_id || '';
                        const stop_sequence = parseInt(st.stop_sequence || '0', 10);
                        if (!tripMap.has(trip_id)) tripMap.set(trip_id, []);
                        tripMap.get(trip_id).push({ stop_id, stop_sequence });
                    }

                    for (const [trip_id, entries] of tripMap.entries()) {
                        entries.sort((a, b) => a.stop_sequence - b.stop_sequence);
                        tripStops.set(trip_id, entries.map(e => e.stop_id));
                    }

                    return true;
                } catch (err) {
                    addTerminalLine(`Error loading trips/stop_times: ${err.message}`, true);
                    return false;
                }
            }

            function findStop(query) {
                if (!query) return null;
                const q = query.trim();

                let found = stopsData.find(stop => stop.stop_id === q);
                if (found) return found;

                found = stopsData.find(stop => stop.stop_name && stop.stop_name.trim().toLowerCase() === q.toLowerCase());
                return found || null;
            }

            function displayStopInfo(stop, query) {
                if (stop) {
                    addTerminalLine(`Found stop: id=${stop.stop_id} name=${stop.stop_name}`);
                } else {
                    addTerminalLine(`No matching stop found for '${query}'.`, true);
                }
            }

            function findTripWithStops(originId, finalId) {
                for (const [trip_id, stopIds] of tripStops.entries()) {
                    const idx1 = stopIds.indexOf(originId);
                    const idx2 = stopIds.indexOf(finalId);
                    if (idx1 !== -1 && idx2 !== -1 && idx1 < idx2) {
                        return { trip_id, stopsBetween: stopIds.slice(idx1, idx2 + 1) };
                    }
                }
                return null;
            }

            // Haversine formula to calculate distance in km between two lat/lon points
            function calculateDistance(lat1, lon1, lat2, lon2) {
                const R = 6371; // Earth's radius in km
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // Calculate total distance for a set of coordinates
            function calculateTotalDistance(coords) {
                if (coords.length < 2) return 0;
                let totalDist = 0;
                for (let i = 0; i < coords.length - 1; i++) {
                    const [lat1, lon1] = coords[i];
                    const [lat2, lon2] = coords[i + 1];
                    totalDist += calculateDistance(lat1, lon1, lat2, lon2);
                }
                return totalDist;
            }

            // Estimate travel time (assuming average speed of 20 km/h for transit)
            function estimateTime(distanceKm) {
                const averageSpeedKmh = 20;
                const timeMinutes = (distanceKm / averageSpeedKmh) * 60;
                return timeMinutes;
            }

            function drawPath(stopIds) {
                if (currentPolyline) map.removeLayer(currentPolyline);
                if (currentMarkersGroup) map.removeLayer(currentMarkersGroup);
                currentConnectorLines.forEach(line => map.removeLayer(line));
                currentConnectorLines = [];

                const latlngs = [];
                const markers = [];
                const markerCoords = [];

                for (let i = 0; i < stopIds.length; i++) {
                    const stopId = stopIds[i];
                    const stop = stopsData.find(s => s.stop_id === stopId);

                    if (stop && stop.stop_lat && stop.stop_lon) {
                        const lat = parseFloat(stop.stop_lat);
                        const lon = parseFloat(stop.stop_lon);
                        const coord = [lat, lon];

                        latlngs.push(coord);
                        markerCoords.push(coord);

                        let color = '#3388ff';
                        let radius = 7;
                        if (i === 0) {
                            color = 'green';
                            radius = 8;
                        } else if (i === stopIds.length - 1) {
                            color = 'red';
                            radius = 8;
                        }

                        const marker = L.circleMarker(coord, {
                            radius: radius,
                            color: color,
                            fillColor: color,
                            fillOpacity: 1,
                            weight: 2
                        });

                        const name = stop.stop_name || 'Unknown';
                        marker.bindPopup(`<strong>${stopId}</strong><br/>${name}`);

                        try {
                            marker.bindTooltip(String(i + 1), {
                                permanent: true,
                                direction: 'center',
                                className: 'stop-label'
                            });
                        } catch (e) {
                            // ignore
                        }

                        markers.push(marker);
                    }
                }

                if (latlngs.length < 2) {
                    addTerminalLine('Not enough coordinates to draw path', true);
                    return false;
                }

                currentPolyline = L.polyline(latlngs, {
                    color: 'blue',
                    weight: 4,
                    opacity: 0.7
                }).addTo(map);

                for (let i = 0; i < markerCoords.length - 1; i++) {
                    const line = L.polyline([markerCoords[i], markerCoords[i + 1]], {
                        color: '#999',
                        weight: 2,
                        opacity: 0.5,
                        dashArray: '5, 5'
                    }).addTo(map);
                    currentConnectorLines.push(line);
                }

                currentMarkersGroup = L.layerGroup(markers).addTo(map);

                if (markers.length > 0) {
                    try { markers[0].openPopup(); } catch (e) { }
                    if (markers.length > 1) {
                        try { markers[markers.length - 1].openPopup(); } catch (e) { }
                    }
                }

                try {
                    map.fitBounds(currentPolyline.getBounds(), { padding: [20, 20] });
                } catch (e) { }

                // Calculate and display distance and time
                const totalDistanceKm = calculateTotalDistance(markerCoords);
                const totalTimeMinutes = estimateTime(totalDistanceKm);
                const hours = Math.floor(totalTimeMinutes / 60);
                const minutes = Math.round(totalTimeMinutes % 60);
                const timeStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

                addTerminalLine(`Distance: ${totalDistanceKm.toFixed(2)} km`);
                addTerminalLine(`Estimated time: ${timeStr}`);

                return true;
            } async function startProgram() {
                if (isRunning) return;

                terminal.innerHTML = '';
                addTerminalLine('$ gec2025 - GTFS Stop Lookup Program\n');

                startBtn.disabled = true;
                restartBtn.disabled = true;
                terminalInput.disabled = false;
                submitBtn.disabled = false;
                isRunning = true;
                inputState = 'waiting_origin';
                originStop = null;
                finalStop = null;

                const stopsLoaded = await loadStopsData();
                if (!stopsLoaded || stopsData.length === 0) {
                    addTerminalLine('Error: Could not load stops data', true);
                    endProgram();
                    return;
                }

                const tripsLoaded = await loadTripsAndStopTimes();
                if (!tripsLoaded) {
                    addTerminalLine('Error: Could not load trips data', true);
                    endProgram();
                    return;
                }

                addTerminalPrompt('Enter origin stop name or stop_id: ');
                terminalInput.focus();
            }

            function endProgram() {
                startBtn.disabled = false;
                restartBtn.disabled = false;
                terminalInput.disabled = true;
                submitBtn.disabled = true;
                isRunning = false;
                inputState = null;
            }

            function handleUserInput() {
                const input = terminalInput.value.trim();
                if (!input) return;

                if (lastPromptEchoSpan) {
                    lastPromptEchoSpan.textContent = input;
                    lastPromptEchoSpan = null;
                }
                terminalInput.value = '';

                if (inputState === 'waiting_origin') {
                    originStop = findStop(input);
                    displayStopInfo(originStop, input);

                    if (originStop) {
                        addTerminalPrompt('Enter final stop name or stop_id: ');
                        inputState = 'waiting_final';
                        terminalInput.focus();
                    } else {
                        addTerminalLine('Please try again.', true);
                        addTerminalPrompt('Enter origin stop name or stop_id: ');
                    }
                } else if (inputState === 'waiting_final') {
                    finalStop = findStop(input);
                    displayStopInfo(finalStop, input);

                    if (finalStop) {
                        
                        const oid = originStop.stop_id;
                        const fid = finalStop.stop_id;
                        const tripResult = findTripWithStops(oid, fid);

                        if (tripResult) {
                            addTerminalLine(`Found trip with ${tripResult.stopsBetween.length} stops`);
                            const ok = drawPath(tripResult.stopsBetween);
                            if (!ok) {
                                addTerminalLine('Failed to draw path', true);
                            }
                        } else {
                            addTerminalLine('No trip found that contains both stops in order', true);
                        }

                        endProgram();
                    } else {
                        addTerminalLine('Please try again.', true);
                        addTerminalPrompt('Enter final stop name or stop_id: ');
                    }
                }
            }

            function restartProgram() {
                startProgram();
            }

            startBtn.addEventListener('click', startProgram);
            restartBtn.addEventListener('click', restartProgram);
            submitBtn.addEventListener('click', handleUserInput);
            terminalInput.addEventListener('keypress', function (e) {
                if (e.key === 'Enter') {
                    handleUserInput();
                }
            });

            terminalInput.disabled = true;
            submitBtn.disabled = true;
            addTerminalLine('Ready. Click "Start" to run the GEC2025 C program.');
        });
    </script>
</body>

</html>