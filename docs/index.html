<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GEC2025 — GTFS route viewer</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <header>
        <h1>GTFS route viewer (University of Guelph)</h1>
    </header>

    <main>
        <section class="project">
            <h2>Load CSVs</h2>

            <div>
                <label style="display:block;font-weight:600;margin-bottom:6px;">
                    Or load CSV files from your computer (will override server files)
                </label>
                <input id="stopsFile" type="file" accept=".csv" />
                <input id="tripsFile" type="file" accept=".csv" />
                <input id="stopTimesFile" type="file" accept=".csv" />
                <div style="font-size:0.85rem;color:#555;margin-top:6px;">
                    If you upload files they will be used instead of fetching ./csv_files/*.csv
                </div>
                <div style="margin-top:8px">
                    <button id="loadCsvBtn">(Re)Load CSVs</button>
                </div>
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>Choose origin & destination</h2>

            <label for="startSelect">Start stop (dropdown)</label>
            <select id="startSelect"></select>

            <label for="endSelect">End stop (dropdown)</label>
            <select id="endSelect"></select>

            <div style="margin:8px 0">— or —</div>

            <!-- These are the "inputs" analogous to gec2025.c origin/final prompts -->
            <label for="origin_input">Origin (name or stop_id)</label>
            <input id="origin_input" type="text" placeholder="e.g. S1 or 'Macdonald Hall'">

            <label for="final_input">Final (name or stop_id)</label>
            <input id="final_input" type="text" placeholder="e.g. S3 or 'Stone Road Mall'">

            <div style="margin-top:10px">
                <button id="getRouteBtn">Get Route / Use Inputs</button>
                <button id="clearRouteBtn" class="secondary">Clear</button>
            </div>

            <div id="directionInfo" style="margin-top:10px"></div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>Map</h2>
            <div id="map"
                style="width:100%;height:520px;margin-top:12px;border-radius:8px;overflow:hidden;position:relative">
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>C source: gec2025.c</h2>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                <a id="downloadLink" href="../gec2025.c" download>Download gec2025.c</a>
                <button id="reloadCBtn">Reload source</button>
                <button id="toggleCBtn">Toggle view</button>
            </div>
            <details id="cDetails" open>
                <summary>Show / hide C source</summary>
                <pre id="csource"
                    style="white-space:pre-wrap;max-height:520px;overflow:auto;background:#f7f7f7;padding:12px;border-radius:6px;border:1px solid #e1e1e1">Loading...</pre>
            </details>
        </section>
    </main>

    <script>
        /* Simple GTFS viewer that accepts uploaded CSVs or fetches ./csv_files/*.csv,
           allows entering origin/final (like gec2025.c prompts) and updates the map. */

        function parseCSV(text) {
            const rows = [];
            let i = 0, cur = [], field = '', inQuotes = false;
            while (i < text.length) {
                const ch = text[i];
                if (inQuotes) {
                    if (ch === '"') { if (text[i + 1] === '"') { field += '"'; i++; } else inQuotes = false; }
                    else field += ch;
                } else {
                    if (ch === '"') inQuotes = true;
                    else if (ch === ',') { cur.push(field); field = ''; }
                    else if (ch === '\r') { }
                    else if (ch === '\n') { cur.push(field); field = ''; rows.push(cur); cur = []; }
                    else field += ch;
                }
                i++;
            }
            if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }
            return rows;
        }

        async function fetchCSV(path) {
            const res = await fetch(path);
            if (!res.ok) throw new Error('Fetch ' + path + ' failed: ' + res.status);
            const txt = await res.text();
            return parseCSV(txt);
        }

        /* Map init */
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let drawn = { poly: null, markers: [] };

        /* Data containers */
        const stops = {}; const stopsList = []; const stopTimesByTrip = {}; const trips = {};
        let stopsFileText = null, tripsFileText = null, stopTimesFileText = null;

        /* UI refs */
        const stopsFile = document.getElementById('stopsFile');
        const tripsFile = document.getElementById('tripsFile');
        const stopTimesFile = document.getElementById('stopTimesFile');
        const loadCsvBtn = document.getElementById('loadCsvBtn');
        const getRouteBtn = document.getElementById('getRouteBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const origin_input = document.getElementById('origin_input');
        const final_input = document.getElementById('final_input');
        const directionInfo = document.getElementById('directionInfo');
        const cpre = document.getElementById('csource');
        const reloadCBtn = document.getElementById('reloadCBtn');
        const toggleCBtn = document.getElementById('toggleCBtn');

        /* Read local files into memory */
        function readLocalFile(file, cb) {
            if (!file) { cb(null); return; }
            const fr = new FileReader();
            fr.onload = () => cb(fr.result);
            fr.onerror = () => cb(null);
            fr.readAsText(file, 'utf-8');
        }
        stopsFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopsFileText = txt; }));
        tripsFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { tripsFileText = txt; }));
        stopTimesFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopTimesFileText = txt; }));

        /* Helpers */
        function clearDrawn() {
            if (drawn.poly) { map.removeLayer(drawn.poly); drawn.poly = null; }
            drawn.markers.forEach(m => map.removeLayer(m)); drawn.markers = [];
            directionInfo.innerHTML = '';
        }
        function drawStopsSequence(seq) {
            clearDrawn();
            const latlngs = seq.map(s => [s.lat, s.lon]);
            drawn.poly = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            seq.forEach((s, i) => {
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} (${s.stop_id})`);
                drawn.markers.push(m);
            });
            try { map.fitBounds(drawn.poly.getBounds(), { padding: [20, 20] }); } catch (e) { }
            directionInfo.innerHTML = `Stops: ${seq.length}`;
        }
        function findStop(query) {
            if (!query) return null;
            query = query.trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            return null;
        }
        function get_route_segment(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        /* Populate selects */
        function populateStopSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const opt = document.createElement('option'); opt.value = ''; opt.textContent = '-- choose or leave blank --';
            startSelect.appendChild(opt.cloneNode(true)); endSelect.appendChild(opt.cloneNode(true));
            stopsList.forEach(s => {
                const label = `${s.stop_name} (${s.stop_id})`;
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = label;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            });
        }

        /* Load GTFS (uploaded files preferred) */
        async function loadGTFS() {
            clearDrawn();
            directionInfo.innerHTML = 'Loading CSVs...';
            const base = './csv_files/';
            try {
                const stopsRows = stopsFileText ? parseCSV(stopsFileText) : await fetchCSV(base + 'stops.csv');
                const tripsRows = tripsFileText ? parseCSV(tripsFileText) : await fetchCSV(base + 'trips.csv').catch(() => null);
                const stopTimesRows = stopTimesFileText ? parseCSV(stopTimesFileText) : await fetchCSV(base + 'stop_times.csv');

                // reset containers
                stopsList.length = 0; for (const k in stops) delete stops[k];
                for (const k in stopTimesByTrip) delete stopTimesByTrip[k];

                if (!stopsRows || stopsRows.length < 2) throw new Error('stops.csv missing or empty');
                const hdrStops = stopsRows[0].map(h => h.trim().toLowerCase());
                let i_id = hdrStops.indexOf('stop_id'), i_name = hdrStops.indexOf('stop_name'),
                    i_lat = hdrStops.indexOf('stop_lat'), i_lon = hdrStops.indexOf('stop_lon');
                if (i_lat === -1) i_lat = hdrStops.indexOf('lat');
                if (i_lon === -1) i_lon = hdrStops.indexOf('lon');
                if (i_name === -1) i_name = hdrStops.indexOf('name');

                for (let i = 1; i < stopsRows.length; i++) {
                    const r = stopsRows[i]; if (!r) continue;
                    const id = (i_id >= 0 && i_id < r.length) ? r[i_id].trim() : null;
                    const name = (i_name >= 0 && i_name < r.length) ? r[i_name].trim() : id;
                    const lat = (i_lat >= 0 && i_lat < r.length) ? parseFloat(r[i_lat].trim()) : NaN;
                    const lon = (i_lon >= 0 && i_lon < r.length) ? parseFloat(r[i_lon].trim()) : NaN;
                    if (!id || isNaN(lat) || isNaN(lon)) continue;
                    const obj = { stop_id: id, stop_name: name, lat: lat, lon: lon };
                    stops[id] = obj; stopsList.push(obj);
                }

                if (stopTimesRows && stopTimesRows.length >= 2) {
                    const hdr = stopTimesRows[0].map(h => h.trim().toLowerCase());
                    const i_trip = hdr.indexOf('trip_id'), i_stop = hdr.indexOf('stop_id');
                    let i_seq = hdr.indexOf('stop_sequence'); if (i_seq === -1) i_seq = hdr.indexOf('sequence');
                    for (let i = 1; i < stopTimesRows.length; i++) {
                        const r = stopTimesRows[i]; if (!r) continue;
                        const tid = (i_trip >= 0 && i_trip < r.length) ? r[i_trip].trim() : null;
                        const sid = (i_stop >= 0 && i_stop < r.length) ? r[i_stop].trim() : null;
                        const seq = (i_seq >= 0 && i_seq < r.length) ? parseInt(r[i_seq].trim(), 10) : i;
                        if (!tid || !sid) continue;
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: seq });
                    }
                }

                populateStopSelects();
                directionInfo.innerHTML = `Loaded stops: ${stopsList.length}, trips: ${Object.keys(stopTimesByTrip).length}`;
            } catch (err) {
                console.error('CSV load error:', err);
                directionInfo.innerHTML = 'CSV load failed: ' + err.message;
                alert('CSV load failed: ' + err.message);
            }
        }

        /* Use origin_input and final_input (like gec2025.c) OR selects, then update map */
        function applyInputsAndUpdateMap() {
            // prefer selects if chosen
            const sId = startSelect.value || null;
            const eId = endSelect.value || null;
            let origin = sId ? stops[sId] : findStop(origin_input.value);
            let final = eId ? stops[eId] : findStop(final_input.value);

            if (!origin || !final) {
                alert('Could not resolve both origin and final stops. Ensure CSVs loaded and inputs correct.');
                return;
            }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            // try to find trip sequence; if none, show direct connection
            const seq = get_route_segment(origin.stop_id, final.stop_id);
            if (!seq) {
                alert('No trip contains both stops in order. Showing direct connection.');
                drawStopsSequence([origin, final]);
                return;
            }
            drawStopsSequence(seq);
        }

        /* Wire UI */
        loadCsvBtn.addEventListener('click', () => loadGTFS());
        getRouteBtn.addEventListener('click', () => applyInputsAndUpdateMap());
        clearRouteBtn.addEventListener('click', () => clearDrawn());

        /* initial attempts */
        loadGTFS();

        /* C source fetch */
        async function loadCSource() {
            cpre.textContent = 'Loading...';
            try {
                const res = await fetch('../gec2025.c');
                if (!res.ok) throw new Error('Fetch failed: ' + res.status);
                cpre.textContent = await res.text();
            } catch (err) {
                cpre.textContent = 'Failed to load gec2025.c: ' + err.message;
            }
        }
        reloadCBtn.addEventListener('click', loadCSource);
        toggleCBtn.addEventListener('click', () => {
            const d = document.getElementById('cDetails'); d.open = !d.open;
        });
        loadCSource();

    </script>
</body>

</html>