<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GEC2025 — GTFS route viewer</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <header>
        <h1>GTFS route viewer (University of Guelph)</h1>
    </header>

    <main>
        <section class="project">
            <h2>Load CSVs</h2>

            <div>
                <label style="display:block;font-weight:600;margin-bottom:6px;">
                    Or load CSV files from your computer (will override server files)
                </label>
                <input id="stopsFile" type="file" accept=".csv" />
                <input id="tripsFile" type="file" accept=".csv" />
                <input id="stopTimesFile" type="file" accept=".csv" />
                <div style="font-size:0.85rem;color:#555;margin-top:6px;">
                    If you upload files they will be used instead of fetching ./csv_files/*.csv
                </div>
                <div style="margin-top:8px">
                    <button id="loadCsvBtn">(Re)Load CSVs</button>
                </div>
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>Choose origin & destination</h2>

            <label for="startSelect">Start stop (dropdown)</label>
            <select id="startSelect"></select>

            <label for="endSelect">End stop (dropdown)</label>
            <select id="endSelect"></select>

            <div style="margin:8px 0">— or —</div>

            <!-- These are the "inputs" analogous to gec2025.c origin/final prompts -->
            <label for="origin_input">Origin (name or stop_id)</label>
            <input id="origin_input" type="text" placeholder="e.g. S1 or 'Macdonald Hall'">

            <label for="final_input">Final (name or stop_id)</label>
            <input id="final_input" type="text" placeholder="e.g. S3 or 'Stone Road Mall'">

            <div style="margin-top:10px">
                <button id="getRouteBtn">Get Route / Use Inputs</button>
                <button id="clearRouteBtn" class="secondary">Clear</button>
            </div>

            <div id="directionInfo" style="margin-top:10px"></div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>Map</h2>
            <div id="map"
                style="width:100%;height:520px;margin-top:12px;border-radius:8px;overflow:hidden;position:relative">
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>C source: gec2025.c</h2>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                <a id="downloadLink" href="../gec2025.c" download>Download gec2025.c</a>
                <button id="reloadCBtn">Reload source</button>
                <button id="toggleCBtn">Toggle view</button>
            </div>
            <details id="cDetails" open>
                <summary>Show / hide C source</summary>
                <pre id="csource"
                    style="white-space:pre-wrap;max-height:520px;overflow:auto;background:#f7f7f7;padding:12px;border-radius:6px;border:1px solid #e1e1e1">Loading...</pre>
            </details>
        </section>

        <div class="project">
            <h2>Run gec2025.c (server execution)</h2>
            <label>Origin (name or stop_id)</label>
            <input id="run_origin" type="text" placeholder="e.g. Macdonald Hall">
            <label>Final (name or stop_id)</label>
            <input id="run_final" type="text" placeholder="e.g. University Centre">
            <div style="margin-top:8px;">
                <button id="runCBtn">Run C program</button>
            </div>
            <pre id="cOutput"
                style="white-space:pre-wrap; background:#f7f7f7; padding:10px; margin-top:8px; max-height:300px; overflow:auto;">Output will appear here</pre>
        </div>
    </main>

    <script>
        /* Simple GTFS viewer that accepts uploaded CSVs or fetches ./csv_files/*.csv,
           allows entering origin/final (like gec2025.c prompts) and updates the map. */

        /* ========== REPLACE: CSV parsing + loading with more robust handling ========== */

        /**
         * parseCSV - robust CSV parser with automatic delimiter detection and BOM trimming.
         * Returns array of rows (each row is array of fields). Handles quoted fields
         * and escaped double-quotes ("").
         */
        function parseCSV(text) {
            if (!text) return [];
            // strip UTF-8 BOM if present
            if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);

            // normalize newlines
            text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

            // detect delimiter by counting occurrences on first non-empty line
            const firstLine = text.split('\n').find(l => l.trim().length > 0) || '';
            const counts = {
                ',': (firstLine.match(/,/g) || []).length,
                ';': (firstLine.match(/;/g) || []).length,
                '\t': (firstLine.match(/\t/g) || []).length
            };
            let delimiter = ',';
            if (counts[';'] > counts[delimiter]) delimiter = ';';
            if (counts['\t'] > counts[delimiter]) delimiter = '\t';

            const rows = [];
            let cur = [], field = '', inQuotes = false;

            for (let i = 0; i < text.length; i++) {
                const ch = text[i];

                if (inQuotes) {
                    if (ch === '"') {
                        if (text[i + 1] === '"') { field += '"'; i++; } // escaped quote
                        else inQuotes = false;
                    } else {
                        field += ch;
                    }
                } else {
                    if (ch === '"') {
                        inQuotes = true;
                    } else if (ch === delimiter) {
                        cur.push(field);
                        field = '';
                    } else if (ch === '\n') {
                        cur.push(field);
                        rows.push(cur);
                        cur = [];
                        field = '';
                    } else {
                        field += ch;
                    }
                }
            }
            // last field/row
            if (field !== '' || cur.length > 0) {
                cur.push(field);
                rows.push(cur);
            }

            // Trim whitespace from all fields and normalize empty-only rows
            const cleaned = rows.map(r => r.map(f => (f === undefined ? '' : String(f).trim())));
            // remove fully-empty trailing rows
            while (cleaned.length && cleaned[cleaned.length - 1].every(c => c === '')) cleaned.pop();
            return cleaned;
        }

        /**
         * fetchCSV - fetches CSV via HTTP and returns parsed rows. Provides clearer error messages.
         */
        async function fetchCSV(path) {
            try {
                const res = await fetch(path);
                if (!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
                const txt = await res.text();
                return parseCSV(txt);
            } catch (err) {
                console.error('fetchCSV failed for', path, err);
                throw err;
            }
        }

        /**
         * loadGTFS - loads stops.csv / trips.csv / stop_times.csv.
         * Accepts uploaded file contents (stopsFileText etc.) or falls back to fetch('./csv_files/...').
         * Improved header handling: case-insensitive, alternate names, logs header mapping to console.
         */
        async function loadGTFS() {
            clearDrawn();
            directionInfo.innerHTML = 'Loading CSVs...';
            const base = './csv_files/';
            try {
                const stopsRows = stopsFileText ? parseCSV(stopsFileText) : await fetchCSV(base + 'stops.csv');
                const tripsRows = tripsFileText ? parseCSV(tripsFileText) : await fetchCSV(base + 'trips.csv').catch(() => null);
                const stopTimesRows = stopTimesFileText ? parseCSV(stopTimesFileText) : await fetchCSV(base + 'stop_times.csv');

                // reset containers
                stopsList.length = 0; for (const k in stops) delete stops[k];
                for (const k in stopTimesByTrip) delete stopTimesByTrip[k];

                if (!stopsRows || stopsRows.length < 1) throw new Error('stops.csv missing or empty');

                // header mapping (case-insensitive)
                const rawHdrStops = stopsRows[0].map(h => (h === undefined ? '' : String(h)));
                const hdrStopsLower = rawHdrStops.map(h => h.trim().toLowerCase());
                let i_id = hdrStopsLower.indexOf('stop_id');
                let i_name = hdrStopsLower.indexOf('stop_name');
                let i_lat = hdrStopsLower.indexOf('stop_lat');
                let i_lon = hdrStopsLower.indexOf('stop_lon');

                // fallback alternatives
                if (i_id === -1) i_id = hdrStopsLower.indexOf('id');
                if (i_name === -1) i_name = hdrStopsLower.indexOf('name');
                if (i_lat === -1) i_lat = hdrStopsLower.indexOf('lat');
                if (i_lon === -1) i_lon = hdrStopsLower.indexOf('lon');

                console.info('stops.csv header mapping', {
                    raw: rawHdrStops,
                    mapping: { i_id, i_name, i_lat, i_lon }
                });

                // if stop_id or lat/lon couldn't be found, try positional fallbacks
                if (i_id === -1) i_id = 0;
                if (i_lat === -1 || i_lon === -1) {
                    // attempt common patterns: lat/lon near end of row
                    for (let i = 0; i < rawHdrStops.length; i++) {
                        const h = hdrStopsLower[i];
                        if (h === 'latitude' || h === 'y' || h === 'lat') i_lat = i;
                        if (h === 'longitude' || h === 'x' || h === 'lon' || h === 'lng') i_lon = i;
                    }
                }

                // Parse stops
                for (let r = 1; r < stopsRows.length; r++) {
                    const row = stopsRows[r];
                    if (!row || row.length === 0) continue;
                    const id = (i_id >= 0 && i_id < row.length) ? String(row[i_id]).trim() : '';
                    const name = (i_name >= 0 && i_name < row.length) ? String(row[i_name]).trim() : id;
                    const lat = (i_lat >= 0 && i_lat < row.length) ? parseFloat(String(row[i_lat]).trim()) : NaN;
                    const lon = (i_lon >= 0 && i_lon < row.length) ? parseFloat(String(row[i_lon]).trim()) : NaN;

                    if (!id || isNaN(lat) || isNaN(lon)) {
                        console.warn(`Skipping stops row ${r} — id/coords invalid`, row);
                        continue;
                    }
                    const obj = { stop_id: id, stop_name: name || id, lat, lon };
                    stops[id] = obj;
                    stopsList.push(obj);
                }

                // Parse stop_times -> group by trip_id
                if (stopTimesRows && stopTimesRows.length >= 1) {
                    const rawHdrStopTimes = stopTimesRows[0].map(h => (h === undefined ? '' : String(h)));
                    const hdrStopTimesLower = rawHdrStopTimes.map(h => h.trim().toLowerCase());
                    const i_trip = hdrStopTimesLower.indexOf('trip_id') !== -1 ? hdrStopTimesLower.indexOf('trip_id') : hdrStopTimesLower.indexOf('trip');
                    const i_stop = hdrStopTimesLower.indexOf('stop_id') !== -1 ? hdrStopTimesLower.indexOf('stop_id') : hdrStopTimesLower.indexOf('stop');
                    let i_seq = hdrStopTimesLower.indexOf('stop_sequence');
                    if (i_seq === -1) {
                        i_seq = hdrStopTimesLower.indexOf('stoporder');
                        if (i_seq === -1) i_seq = hdrStopTimesLower.indexOf('sequence');
                    }

                    console.info('stop_times.csv header mapping', { raw: rawHdrStopTimes, mapping: { i_trip, i_stop, i_seq } });

                    for (let r = 1; r < stopTimesRows.length; r++) {
                        const row = stopTimesRows[r];
                        if (!row || row.length === 0) continue;
                        const tid = (i_trip >= 0 && i_trip < row.length) ? String(row[i_trip]).trim() : '';
                        const sid = (i_stop >= 0 && i_stop < row.length) ? String(row[i_stop]).trim() : '';
                        const seq = (i_seq >= 0 && i_seq < row.length) ? parseInt(String(row[i_seq]).trim(), 10) : r;
                        if (!tid || !sid) {
                            console.warn(`Skipping stop_times row ${r} — missing trip_id or stop_id`, row);
                            continue;
                        }
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: isNaN(seq) ? r : seq });
                    }
                }

                populateStopSelects();
                console.info('Loaded GTFS', { stops: stopsList.length, trips: Object.keys(stopTimesByTrip).length });
                directionInfo.innerHTML = `Loaded stops: ${stopsList.length}, trips: ${Object.keys(stopTimesByTrip).length}`;
            } catch (err) {
                console.error('CSV load error:', err);
                directionInfo.innerHTML = 'CSV load failed: ' + (err && err.message ? err.message : err);
                throw err;
            }
        }

        /* Map init */
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let drawn = { poly: null, markers: [] };

        /* Data containers */
        const stops = {}; const stopsList = []; const stopTimesByTrip = {}; const trips = {};
        let stopsFileText = null, tripsFileText = null, stopTimesFileText = null;

        /* UI refs */
        const stopsFile = document.getElementById('stopsFile');
        const tripsFile = document.getElementById('tripsFile');
        const stopTimesFile = document.getElementById('stopTimesFile');
        const loadCsvBtn = document.getElementById('loadCsvBtn');
        const getRouteBtn = document.getElementById('getRouteBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const origin_input = document.getElementById('origin_input');
        const final_input = document.getElementById('final_input');
        const directionInfo = document.getElementById('directionInfo');
        const cpre = document.getElementById('csource');
        const reloadCBtn = document.getElementById('reloadCBtn');
        const toggleCBtn = document.getElementById('toggleCBtn');

        /* Read local files into memory */
        function readLocalFile(file, cb) {
            if (!file) { cb(null); return; }
            const fr = new FileReader();
            fr.onload = () => cb(fr.result);
            fr.onerror = () => cb(null);
            fr.readAsText(file, 'utf-8');
        }
        stopsFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopsFileText = txt; }));
        tripsFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { tripsFileText = txt; }));
        stopTimesFile.addEventListener('change', e => readLocalFile(e.target.files[0], txt => { stopTimesFileText = txt; }));

        /* Helpers */
        function clearDrawn() {
            if (drawn.poly) { map.removeLayer(drawn.poly); drawn.poly = null; }
            drawn.markers.forEach(m => map.removeLayer(m)); drawn.markers = [];
            directionInfo.innerHTML = '';
        }
        function drawStopsSequence(seq) {
            clearDrawn();
            const latlngs = seq.map(s => [s.lat, s.lon]);
            drawn.poly = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            seq.forEach((s, i) => {
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} (${s.stop_id})`);
                drawn.markers.push(m);
            });
            try { map.fitBounds(drawn.poly.getBounds(), { padding: [20, 20] }); } catch (e) { }
            directionInfo.innerHTML = `Stops: ${seq.length}`;
        }
        function findStop(query) {
            if (!query) return null;
            query = query.trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            return null;
        }
        function get_route_segment(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        /* Populate selects */
        function populateStopSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const opt = document.createElement('option'); opt.value = ''; opt.textContent = '-- choose or leave blank --';
            startSelect.appendChild(opt.cloneNode(true)); endSelect.appendChild(opt.cloneNode(true));
            stopsList.forEach(s => {
                const label = `${s.stop_name} (${s.stop_id})`;
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = label;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            });
        }

        /* Load GTFS (uploaded files preferred) */
        async function loadGTFS() {
            clearDrawn();
            directionInfo.innerHTML = 'Loading CSVs...';
            const base = './csv_files/';
            try {
                const stopsRows = stopsFileText ? parseCSV(stopsFileText) : await fetchCSV(base + 'stops.csv');
                const tripsRows = tripsFileText ? parseCSV(tripsFileText) : await fetchCSV(base + 'trips.csv').catch(() => null);
                const stopTimesRows = stopTimesFileText ? parseCSV(stopTimesFileText) : await fetchCSV(base + 'stop_times.csv');

                // reset containers
                stopsList.length = 0; for (const k in stops) delete stops[k];
                for (const k in stopTimesByTrip) delete stopTimesByTrip[k];

                if (!stopsRows || stopsRows.length < 1) throw new Error('stops.csv missing or empty');

                // header mapping (case-insensitive)
                const rawHdrStops = stopsRows[0].map(h => (h === undefined ? '' : String(h)));
                const hdrStopsLower = rawHdrStops.map(h => h.trim().toLowerCase());
                let i_id = hdrStopsLower.indexOf('stop_id');
                let i_name = hdrStopsLower.indexOf('stop_name');
                let i_lat = hdrStopsLower.indexOf('stop_lat');
                let i_lon = hdrStopsLower.indexOf('stop_lon');

                // fallback alternatives
                if (i_id === -1) i_id = hdrStopsLower.indexOf('id');
                if (i_name === -1) i_name = hdrStopsLower.indexOf('name');
                if (i_lat === -1) i_lat = hdrStopsLower.indexOf('lat');
                if (i_lon === -1) i_lon = hdrStopsLower.indexOf('lon');

                console.info('stops.csv header mapping', {
                    raw: rawHdrStops,
                    mapping: { i_id, i_name, i_lat, i_lon }
                });

                // if stop_id or lat/lon couldn't be found, try positional fallbacks
                if (i_id === -1) i_id = 0;
                if (i_lat === -1 || i_lon === -1) {
                    // attempt common patterns: lat/lon near end of row
                    for (let i = 0; i < rawHdrStops.length; i++) {
                        const h = hdrStopsLower[i];
                        if (h === 'latitude' || h === 'y' || h === 'lat') i_lat = i;
                        if (h === 'longitude' || h === 'x' || h === 'lon' || h === 'lng') i_lon = i;
                    }
                }

                // Parse stops
                for (let r = 1; r < stopsRows.length; r++) {
                    const row = stopsRows[r];
                    if (!row || row.length === 0) continue;
                    const id = (i_id >= 0 && i_id < row.length) ? String(row[i_id]).trim() : '';
                    const name = (i_name >= 0 && i_name < row.length) ? String(row[i_name]).trim() : id;
                    const lat = (i_lat >= 0 && i_lat < row.length) ? parseFloat(String(row[i_lat]).trim()) : NaN;
                    const lon = (i_lon >= 0 && i_lon < row.length) ? parseFloat(String(row[i_lon]).trim()) : NaN;

                    if (!id || isNaN(lat) || isNaN(lon)) {
                        console.warn(`Skipping stops row ${r} — id/coords invalid`, row);
                        continue;
                    }
                    const obj = { stop_id: id, stop_name: name || id, lat, lon };
                    stops[id] = obj;
                    stopsList.push(obj);
                }

                // Parse stop_times -> group by trip_id
                if (stopTimesRows && stopTimesRows.length >= 1) {
                    const rawHdrStopTimes = stopTimesRows[0].map(h => (h === undefined ? '' : String(h)));
                    const hdrStopTimesLower = rawHdrStopTimes.map(h => h.trim().toLowerCase());
                    const i_trip = hdrStopTimesLower.indexOf('trip_id') !== -1 ? hdrStopTimesLower.indexOf('trip_id') : hdrStopTimesLower.indexOf('trip');
                    const i_stop = hdrStopTimesLower.indexOf('stop_id') !== -1 ? hdrStopTimesLower.indexOf('stop_id') : hdrStopTimesLower.indexOf('stop');
                    let i_seq = hdrStopTimesLower.indexOf('stop_sequence');
                    if (i_seq === -1) {
                        i_seq = hdrStopTimesLower.indexOf('stoporder');
                        if (i_seq === -1) i_seq = hdrStopTimesLower.indexOf('sequence');
                    }

                    console.info('stop_times.csv header mapping', { raw: rawHdrStopTimes, mapping: { i_trip, i_stop, i_seq } });

                    for (let r = 1; r < stopTimesRows.length; r++) {
                        const row = stopTimesRows[r];
                        if (!row || row.length === 0) continue;
                        const tid = (i_trip >= 0 && i_trip < row.length) ? String(row[i_trip]).trim() : '';
                        const sid = (i_stop >= 0 && i_stop < row.length) ? String(row[i_stop]).trim() : '';
                        const seq = (i_seq >= 0 && i_seq < row.length) ? parseInt(String(row[i_seq]).trim(), 10) : r;
                        if (!tid || !sid) {
                            console.warn(`Skipping stop_times row ${r} — missing trip_id or stop_id`, row);
                            continue;
                        }
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: isNaN(seq) ? r : seq });
                    }
                }

                populateStopSelects();
                console.info('Loaded GTFS', { stops: stopsList.length, trips: Object.keys(stopTimesByTrip).length });
                directionInfo.innerHTML = `Loaded stops: ${stopsList.length}, trips: ${Object.keys(stopTimesByTrip).length}`;
            } catch (err) {
                console.error('CSV load error:', err);
                directionInfo.innerHTML = 'CSV load failed: ' + (err && err.message ? err.message : err);
                throw err;
            }
        }

        /* Use origin_input and final_input (like gec2025.c) OR selects, then update map */
        function applyInputsAndUpdateMap() {
            // prefer selects if chosen
            const sId = startSelect.value || null;
            const eId = endSelect.value || null;
            let origin = sId ? stops[sId] : findStop(origin_input.value);
            let final = eId ? stops[eId] : findStop(final_input.value);

            if (!origin || !final) {
                alert('Could not resolve both origin and final stops. Ensure CSVs loaded and inputs correct.');
                return;
            }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            // try to find trip sequence; if none, show direct connection
            const seq = get_route_segment(origin.stop_id, final.stop_id);
            if (!seq) {
                alert('No trip contains both stops in order. Showing direct connection.');
                drawStopsSequence([origin, final]);
                return;
            }
            drawStopsSequence(seq);
        }

        /* Wire UI */
        loadCsvBtn.addEventListener('click', () => loadGTFS());
        getRouteBtn.addEventListener('click', () => applyInputsAndUpdateMap());
        clearRouteBtn.addEventListener('click', () => clearDrawn());

        /* initial attempts */
        loadGTFS();

        /* C source fetch */
        async function loadCSource() {
            cpre.textContent = 'Loading...';
            try {
                const res = await fetch('../gec2025.c');
                if (!res.ok) throw new Error('Fetch failed: ' + res.status);
                cpre.textContent = await res.text();
            } catch (err) {
                cpre.textContent = 'Failed to load gec2025.c: ' + err.message;
            }
        }
        reloadCBtn.addEventListener('click', loadCSource);
        toggleCBtn.addEventListener('click', () => {
            const d = document.getElementById('cDetails'); d.open = !d.open;
        });
        loadCSource();

        // call /run-gec2025 on server
        document.getElementById('runCBtn').addEventListener('click', async () => {
            const origin = document.getElementById('run_origin').value || '';
            const finalStop = document.getElementById('run_final').value || '';
            document.getElementById('cOutput').textContent = 'Running...';
            try {
                const r = await fetch('/run-gec2025', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ origin, final: finalStop })
                });
                const j = await r.json();
                let out = '';
                out += `exit code: ${j.code}\n\n`;
                if (j.stdout) out += 'STDOUT:\n' + j.stdout + '\n';
                if (j.stderr) out += 'STDERR:\n' + j.stderr + '\n';
                document.getElementById('cOutput').textContent = out;
            } catch (err) {
                document.getElementById('cOutput').textContent = 'Request failed: ' + String(err);
            }
        });
    </script>
</body>

</html>