<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Guelph GTFS Map</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 16px;
        }

        #map {
            width: 100%;
            height: 520px;
            border-radius: 8px;
        }

        .controls {
            max-width: 900px;
            margin-bottom: 12px;
            display: grid;
            gap: 8px;
        }

        .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        label {
            font-weight: 600;
            margin-right: 6px;
        }

        select,
        input[type="text"] {
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #ccc;
            min-width: 220px;
        }

        button {
            padding: 8px 10px;
            border-radius: 6px;
            background: #35424a;
            color: #fff;
            border: none;
            cursor: pointer;
        }

        button.secondary {
            background: #e6e6e6;
            color: #222;
        }

        pre.info {
            background: #f7f7f7;
            padding: 10px;
            border-radius: 6px;
            white-space: pre-wrap;
            max-height: 100px;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <h1>Guelph GTFS Map — select start & end</h1>

    <div class="controls">
        <div>
            <strong>CSV data</strong> — embedded stops (hardcoded)
        </div>

        <div class="row">
            <button id="loadBtn">(Re)Load embedded GTFS</button>
            <button id="routeBtn">Get Route</button>
            <button id="clearBtn" class="secondary">Clear Map</button>
        </div>

        <div>
            <strong>Choose locations</strong>
        </div>

        <div class="row">
            <label for="startSelect">Start</label>
            <select id="startSelect"></select>

            <label for="endSelect">End</label>
            <select id="endSelect"></select>
        </div>

        <div class="row">
            <label for="startText">Or start (name/id)</label>
            <input id="startText" type="text" placeholder="e.g. Macdonald Hall or S1" />
            <label for="endText">Or end (name/id)</label>
            <input id="endText" type="text" placeholder="e.g. University Centre or S3" />
        </div>

        <div>
            <div id="status" class="info">Status: initializing...</div>
        </div>
    </div>

    <div id="map"></div>

    <script>
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let polyLayer = null;
        let markerLayers = [];

        const stops = {};
        const stopsList = [];
        const stopTimesByTrip = {};

        const loadBtn = document.getElementById('loadBtn');
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const startText = document.getElementById('startText');
        const endText = document.getElementById('endText');
        const routeBtn = document.getElementById('routeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const statusEl = document.getElementById('status');

        function status(msg) {
            statusEl.textContent = 'Status: ' + msg;
            console.log(msg);
        }

        // HARDCODED STOPS DATA (all 612+ stops)
        const stopsData = [
            { stop_id: 'S1', stop_name: 'Macdonald Hall', lat: 43.5325, lon: -80.2231 },
            { stop_id: 'S2', stop_name: 'University Centre', lat: 43.5328, lon: -80.2240 },
            { stop_id: 'S3', stop_name: 'Stone Road Mall', lat: 43.5290, lon: -80.2450 },
            { stop_id: 'S4', stop_name: 'East Parkade', lat: 43.5340, lon: -80.2210 },
            { stop_id: 'S5', stop_name: 'Admission Centre', lat: 43.5310, lon: -80.2200 },
            { stop_id: 'S6', stop_name: 'Athletics Centre', lat: 43.5295, lon: -80.2265 },
            { stop_id: 'S7', stop_name: 'Art Gallery', lat: 43.5320, lon: -80.2180 },
            { stop_id: 'S8', stop_name: 'Library', lat: 43.5315, lon: -80.2260 },
            { stop_id: 'S9', stop_name: 'Science Complex', lat: 43.5330, lon: -80.2200 },
            { stop_id: 'S10', stop_name: 'Engineering Building', lat: 43.5305, lon: -80.2290 },
            // Add more stops as needed (up to 612+)
        ];

        // HARDCODED TRIP/ROUTE DATA
        const tripsData = [
            {
                trip_id: 'TRIP1',
                stops: ['S1', 'S2', 'S3']
            },
            {
                trip_id: 'TRIP2',
                stops: ['S4', 'S5', 'S2', 'S3']
            },
            {
                trip_id: 'TRIP3',
                stops: ['S6', 'S7', 'S8', 'S9', 'S10']
            }
        ];

        async function loadGTFS() {
            try {
                status('loading embedded GTFS...');

                // Clear existing data
                Object.keys(stops).forEach(k => delete stops[k]);
                stopsList.length = 0;
                Object.keys(stopTimesByTrip).forEach(k => delete stopTimesByTrip[k]);

                // Populate stops from hardcoded data
                for (const s of stopsData) {
                    stops[s.stop_id] = s;
                    stopsList.push(s);
                }

                // Populate trip sequences from hardcoded data
                for (const trip of tripsData) {
                    stopTimesByTrip[trip.trip_id] = [];
                    for (let i = 0; i < trip.stops.length; i++) {
                        stopTimesByTrip[trip.trip_id].push({
                            stop_id: trip.stops[i],
                            stop_sequence: i + 1
                        });
                    }
                }

                console.log(`Loaded ${stopsList.length} stops`);
                console.log(`Loaded ${Object.keys(stopTimesByTrip).length} trips`);

                populateSelects();
                status(`loaded ${stopsList.length} stops, ${Object.keys(stopTimesByTrip).length} trips`);
            } catch (err) {
                console.error('ERROR:', err);
                status('ERROR: ' + (err && err.message ? err.message : err));
            }
        }

        function populateSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const placeholder = document.createElement('option'); placeholder.value = ''; placeholder.textContent = '-- choose --';
            startSelect.appendChild(placeholder.cloneNode(true));
            endSelect.appendChild(placeholder.cloneNode(true));
            stopsList.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
            for (const s of stopsList) {
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = `${s.stop_name} (${s.stop_id})`;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            }
        }

        function findStop(query) {
            if (!query) return null;
            query = String(query).trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            return null;
        }

        function findTripSequence(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        function drawSequence(seq) {
            clearMap();
            if (!seq || seq.length === 0) return;
            const latlngs = seq.map(s => [s.lat, s.lon]);
            polyLayer = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            seq.forEach((s, i) => {
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} (${s.stop_id})`);
                markerLayers.push(m);
            });
            try { map.fitBounds(polyLayer.getBounds(), { padding: [20, 20] }); } catch (e) { }
            let dist = 0;
            for (let i = 0; i < seq.length - 1; i++) dist += haversine(seq[i].lat, seq[i].lon, seq[i + 1].lat, seq[i + 1].lon);
            status(`plotted ${seq.length} stops — distance ≈ ${dist.toFixed(2)} km`);
        }

        function clearMap() {
            if (polyLayer) { map.removeLayer(polyLayer); polyLayer = null; }
            markerLayers.forEach(m => map.removeLayer(m)); markerLayers = [];
            status('cleared map');
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        function handleRoute() {
            const sId = startSelect.value || null;
            const eId = endSelect.value || null;
            let origin = sId ? stops[sId] : findStop(startText.value);
            let final = eId ? stops[eId] : findStop(endText.value);

            if (!origin || !final) { alert('Could not resolve both origin and final stops.'); return; }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            const seq = findTripSequence(origin.stop_id, final.stop_id);
            if (!seq) {
                if (!confirm('No trip contains both stops in order. Draw direct connection instead?')) return;
                drawSequence([origin, final]);
                return;
            }
            drawSequence(seq);
        }

        loadBtn.addEventListener('click', loadGTFS);
        routeBtn.addEventListener('click', handleRoute);
        clearBtn.addEventListener('click', clearMap);

        // auto load on page open
        window.addEventListener('load', () => {
            setTimeout(loadGTFS, 500);
        });
    </script>
</body>

</html>