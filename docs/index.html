<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GEC2025 — GTFS route viewer</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <header>
        <h1>GTFS route viewer (University of Guelph)</h1>
    </header>
    <main>
        <section class="project">
            <h2>Directions from GTFS</h2>

            <!-- Controls: either pick from dropdowns or type a name/ID -->
            <div id="directions-controls">
                <label for="startSelect">Start stop (dropdown)</label>
                <select id="startSelect"></select>

                <label for="endSelect">End stop (dropdown)</label>
                <select id="endSelect"></select>

                <div style="margin:8px 0">— or —</div>

                <label for="startText">Start (name or id)</label>
                <input id="startText" type="text" placeholder="e.g. S1 or 'University Centre'">

                <label for="endText">End (name or id)</label>
                <input id="endText" type="text" placeholder="e.g. S3 or 'Macdonald Hall'">

                <div style="margin-top:10px">
                    <button id="loadCsvBtn">(Re)Load CSVs</button>
                    <button id="getRouteBtn">Get Route</button>
                    <button id="clearRouteBtn" class="secondary">Clear</button>
                </div>

                <div id="directionInfo" style="margin-top:10px"></div>
            </div>

            <div id="map"
                style="width:100%;height:520px;margin-top:12px;border-radius:8px;overflow:hidden;position:relative">
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>Route Analysis (GEC2025 Functions)</h2>
            <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
                <button id="analyzeBtn">Analyze Loaded Routes</button>
                <button id="findStopsBtn">Find Stops in Trip</button>
                <button id="calcDistanceBtn">Calculate Distance</button>
            </div>
            <div id="analysisInfo"
                style="background:#f8f8f8;padding:10px;border-radius:6px;border-left:4px solid #35424a;min-height:40px;white-space:pre-wrap;font-size:0.9rem;">
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>C source: gec2025.c</h2>
            <p>
                The repository contains gec2025.c at the project root. You can download it
                directly or view the source below. (Requires the parent directory to be
                served by your HTTP server so "../gec2025.c" is reachable.)
            </p>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                <a id="downloadLink" href="../gec2025.c" download>Download gec2025.c</a>
                <button id="reloadCBtn">Reload source</button>
                <button id="toggleCBtn">Toggle view</button>
            </div>

            <details id="cDetails" open>
                <summary>Show / hide C source</summary>
                <pre id="csource"
                    style="white-space:pre-wrap;max-height:520px;overflow:auto;background:#f7f7f7;padding:12px;border-radius:6px;border:1px solid #e1e1e1">Loading...</pre>
            </details>
        </section>
    </main>

    <script>
        /* ============================================================================
           GEC2025 GTFS Transit Route Viewer
           Integrates C-like functionality: stop search, route analysis, distance calc
           ============================================================================ */

        /* --- CSV Parsing --- */
        function parseCSV(text) {
            const rows = [];
            let i = 0, cur = [], field = '', inQuotes = false;
            while (i < text.length) {
                const ch = text[i];
                if (inQuotes) {
                    if (ch === '"') {
                        if (text[i + 1] === '"') { field += '"'; i++; }
                        else inQuotes = false;
                    } else field += ch;
                } else {
                    if (ch === '"') inQuotes = true;
                    else if (ch === ',') { cur.push(field); field = ''; }
                    else if (ch === '\r') { }
                    else if (ch === '\n') { cur.push(field); field = ''; rows.push(cur); cur = []; }
                    else field += ch;
                }
                i++;
            }
            if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }
            return rows;
        }

        async function fetchCSV(path) {
            const res = await fetch(path);
            if (!res.ok) throw new Error('Fetch ' + path + ' failed: ' + res.status);
            const txt = await res.text();
            return parseCSV(txt);
        }

        /* --- Map init --- */
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let drawn = { poly: null, markers: [] };

        /* --- Data structures (mimic C structs) --- */
        const stops = {};       // stop_id -> {stop_id, stop_name, lat, lon}
        const stopsList = [];   // array of stop objects
        const stopTimesByTrip = {}; // trip_id -> [{stop_id, stop_sequence}, ...]
        const trips = {};       // trip_id -> {trip_id, route_id, direction_id}
        const routes_data = {}; // route_id -> {route_id, route_name, ...}

        /* --- UI refs --- */
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const startText = document.getElementById('startText');
        const endText = document.getElementById('endText');
        const loadCsvBtn = document.getElementById('loadCsvBtn');
        const getRouteBtn = document.getElementById('getRouteBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        const directionInfo = document.getElementById('directionInfo');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const findStopsBtn = document.getElementById('findStopsBtn');
        const calcDistanceBtn = document.getElementById('calcDistanceBtn');
        const analysisInfo = document.getElementById('analysisInfo');

        /* ============================================================================
           GEC2025-STYLE FUNCTIONS (C logic ported to JS)
           ============================================================================ */

        /**
         * find_stop_in_csv - Search for a stop by ID or name (case-insensitive)
         * Mimics C: int find_stop_in_csv(const char* query)
         */
        function find_stop_in_csv(query) {
            if (!query) return -1;
            query = query.trim();
            // exact ID match first
            if (stops[query]) return 1; // found by ID
            // substring name match
            const q = query.toLowerCase();
            for (const id in stops) {
                if (stops[id].stop_name && stops[id].stop_name.toLowerCase().includes(q)) {
                    return 1; // found by name
                }
            }
            return 0; // not found
        }

        /**
         * find_stops_in_trip - Get all stops in a trip sequence
         * Mimics C: void find_stops_in_trip(trip_id)
         */
        function find_stops_in_trip(tripId) {
            if (!stopTimesByTrip[tripId]) return [];
            const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
            const out = [];
            for (const st of seq) {
                const s = stops[st.stop_id];
                if (s) out.push({ ...s, stop_sequence: st.stop_sequence });
            }
            return out;
        }

        /**
         * calculate_distance - Haversine distance between two lat/lon points (in km)
         * Mimics C haversine calculation
         */
        function calculate_distance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        /**
         * analyze_route - Compute stats for a trip: total distance, stops, etc.
         */
        function analyze_route(tripId) {
            const seq = find_stops_in_trip(tripId);
            if (seq.length < 2) return null;
            let totalDist = 0;
            for (let i = 0; i < seq.length - 1; i++) {
                const d = calculate_distance(seq[i].lat, seq[i].lon, seq[i + 1].lat, seq[i + 1].lon);
                totalDist += d;
            }
            return {
                trip_id: tripId,
                num_stops: seq.length,
                total_distance_km: totalDist.toFixed(2),
                stops: seq
            };
        }

        /**
         * get_route_segment - Find shortest trip connecting two stops
         */
        function get_route_segment(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        /* Populate dropdowns from stopsList */
        function populateStopSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const optClick = document.createElement('option');
            optClick.value = ''; optClick.textContent = '-- choose or leave blank to use text input --';
            startSelect.appendChild(optClick.cloneNode(true));
            endSelect.appendChild(optClick.cloneNode(true));
            for (const s of stopsList) {
                const label = `${s.stop_name} (${s.stop_id})`;
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = label;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            }
        }

        /* Find stop by id or name */
        function findStop(query) {
            if (!query) return null;
            query = query.trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) {
                if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            }
            return null;
        }

        /* Clear previously drawn route */
        function clearDrawn() {
            if (drawn.poly) { map.removeLayer(drawn.poly); drawn.poly = null; }
            drawn.markers.forEach(m => map.removeLayer(m)); drawn.markers = [];
            directionInfo.innerHTML = '';
        }

        /* Draw sequence of stops */
        function drawStopsSequence(seq) {
            clearDrawn();
            const latlngs = seq.map(s => [s.lat, s.lon]);
            drawn.poly = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            for (let i = 0; i < seq.length; i++) {
                const s = seq[i];
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} <br/>ID: ${s.stop_id}`);
                drawn.markers.push(m);
            }
            map.fitBounds(drawn.poly.getBounds(), { padding: [20, 20] });
            directionInfo.innerHTML = `Stops in route: ${seq.length}.`;
        }

        /* Compute route */
        function computeRoute() {
            const originId = startSelect.value || null;
            const endId = endSelect.value || null;
            let origin = null, final = null;

            if (originId) origin = stops[originId];
            if (endId) final = stops[endId];

            if (!origin) origin = findStop(startText.value);
            if (!final) final = findStop(endText.value);

            if (!origin || !final) {
                alert('Could not resolve both origin and final stops.');
                return;
            }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            const seq = get_route_segment(origin.stop_id, final.stop_id);
            if (!seq) {
                alert('No trip found. Showing direct connection.');
                drawStopsSequence([origin, final]);
                return;
            }
            drawStopsSequence(seq);
        }

        /* Load CSVs */
        async function loadGTFS() {
            clearDrawn();
            directionInfo.innerHTML = 'Loading CSVs...';
            const base = './csv_files/';
            try {
                const [stopsRows, tripsRows, stopTimesRows] = await Promise.all([
                    fetchCSV(base + 'stops.csv'),
                    fetchCSV(base + 'trips.csv').catch(() => null),
                    fetchCSV(base + 'stop_times.csv')
                ]);

                stopsList.length = 0;
                for (const k in stops) delete stops[k];
                if (!stopsRows || stopsRows.length < 2) throw new Error('stops.csv missing or empty');
                const hdrStops = stopsRows[0].map(h => h.trim());
                const i_id = hdrStops.indexOf('stop_id'), i_name = hdrStops.indexOf('stop_name'), i_lat = hdrStops.indexOf('stop_lat'), i_lon = hdrStops.indexOf('stop_lon');
                for (let i = 1; i < stopsRows.length; i++) {
                    const r = stopsRows[i];
                    if (!r) continue;
                    const id = (i_id >= 0 && i_id < r.length) ? r[i_id].trim() : null;
                    const name = (i_name >= 0 && i_name < r.length) ? r[i_name].trim() : id;
                    const lat = (i_lat >= 0 && i_lat < r.length) ? parseFloat(r[i_lat]) : NaN;
                    const lon = (i_lon >= 0 && i_lon < r.length) ? parseFloat(r[i_lon]) : NaN;
                    if (!id || isNaN(lat) || isNaN(lon)) continue;
                    const obj = { stop_id: id, stop_name: name, lat: lat, lon: lon };
                    stops[id] = obj; stopsList.push(obj);
                }

                for (const k in stopTimesByTrip) delete stopTimesByTrip[k];
                if (stopTimesRows && stopTimesRows.length >= 2) {
                    const hdr = stopTimesRows[0].map(h => h.trim());
                    const i_trip = hdr.indexOf('trip_id'), i_stop = hdr.indexOf('stop_id'), i_seq = hdr.indexOf('stop_sequence');
                    for (let i = 1; i < stopTimesRows.length; i++) {
                        const r = stopTimesRows[i];
                        if (!r) continue;
                        const tid = (i_trip >= 0 && i_trip < r.length) ? r[i_trip].trim() : null;
                        const sid = (i_stop >= 0 && i_stop < r.length) ? r[i_stop].trim() : null;
                        const seq = (i_seq >= 0 && i_seq < r.length) ? parseInt(r[i_seq], 10) : i;
                        if (!tid || !sid) continue;
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: seq });
                    }
                }

                populateStopSelects();
                directionInfo.innerHTML = `Loaded stops: ${stopsList.length}, trips: ${Object.keys(stopTimesByTrip).length}`;
            } catch (err) {
                console.error(err);
                alert('CSV load failed: ' + err.message);
                directionInfo.innerHTML = 'CSV load failed';
            }
        }

        /* --- Analysis functions (GEC2025 features) --- */
        analyzeBtn.addEventListener('click', () => {
            const tripIds = Object.keys(stopTimesByTrip);
            if (tripIds.length === 0) { analysisInfo.textContent = 'No trips loaded.'; return; }
            let out = 'Route Analysis:\n\n';
            let totalDist = 0, totalStops = 0;
            for (let i = 0; i < Math.min(tripIds.length, 5); i++) {
                const analysis = analyze_route(tripIds[i]);
                if