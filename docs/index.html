<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GEC2025 — GTFS route viewer</title>
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <header>
        <h1>GTFS route viewer (University of Guelph)</h1>
    </header>
    <main>
        <section class="project">
            <h2>Directions from GTFS</h2>

            <!-- Controls: either pick from dropdowns or type a name/ID -->
            <div id="directions-controls">
                <label for="startSelect">Start stop (dropdown)</label>
                <select id="startSelect"></select>

                <label for="endSelect">End stop (dropdown)</label>
                <select id="endSelect"></select>

                <div style="margin:8px 0">— or —</div>

                <label for="startText">Start (name or id)</label>
                <input id="startText" type="text" placeholder="e.g. S1 or 'University Centre'">

                <label for="endText">End (name or id)</label>
                <input id="endText" type="text" placeholder="e.g. S3 or 'Macdonald Hall'">

                <div style="margin-top:10px">
                    <button id="loadCsvBtn">(Re)Load CSVs</button>
                    <button id="getRouteBtn">Get Route</button>
                    <button id="clearRouteBtn" class="secondary">Clear</button>
                </div>

                <div id="directionInfo" style="margin-top:10px"></div>
            </div>

            <div id="map"
                style="width:100%;height:520px;margin-top:12px;border-radius:8px;overflow:hidden;position:relative">
            </div>
        </section>

        <section class="project" style="margin-top:18px;">
            <h2>C source: gec2025.c</h2>
            <p>
                The repository contains gec2025.c at the project root. You can download it
                directly or view the source below. (Requires the parent directory to be
                served by your HTTP server so "../gec2025.c" is reachable.)
            </p>
            <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                <a id="downloadLink" href="../gec2025.c" download>Download gec2025.c</a>
                <button id="reloadCBtn">Reload source</button>
                <button id="toggleCBtn">Toggle view</button>
            </div>

            <details id="cDetails" open>
                <summary>Show / hide C source</summary>
                <pre id="csource"
                    style="white-space:pre-wrap;max-height:520px;overflow:auto;background:#f7f7f7;padding:12px;border-radius:6px;border:1px solid #e1e1e1">Loading...</pre>
            </details>
        </section>
    </main>

    <script>
        /* Integrated JS: loads GTFS CSVs, finds a trip that contains both stops,
           extracts intermediate stops in-sequence and draws them on a Leaflet map.
           Also fetches and displays the gec2025.c source file (served from parent dir). */

        /* --- Helpers --- */
        function parseCSV(text) {
            const rows = [];
            let i = 0, cur = [], field = '', inQuotes = false;
            while (i < text.length) {
                const ch = text[i];
                if (inQuotes) {
                    if (ch === '"') {
                        if (text[i + 1] === '"') { field += '"'; i++; }
                        else inQuotes = false;
                    } else field += ch;
                } else {
                    if (ch === '"') inQuotes = true;
                    else if (ch === ',') { cur.push(field); field = ''; }
                    else if (ch === '\r') { }
                    else if (ch === '\n') { cur.push(field); field = ''; rows.push(cur); cur = []; }
                    else field += ch;
                }
                i++;
            }
            if (field !== '' || cur.length) { cur.push(field); rows.push(cur); }
            return rows;
        }

        async function fetchCSV(path) {
            const res = await fetch(path);
            if (!res.ok) throw new Error('Fetch ' + path + ' failed: ' + res.status);
            const txt = await res.text();
            return parseCSV(txt);
        }

        /* --- Map init --- */
        const map = L.map('map').setView([43.5322, -80.2230], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

        let drawn = { poly: null, markers: [] };

        /* --- Data containers --- */
        const stops = {};       // stop_id -> {stop_id, stop_name, lat, lon}
        const stopsList = [];   // array of stop objects (for select)
        const stopTimesByTrip = {}; // trip_id -> [{stop_id, stop_sequence}, ...]
        const trips = {};       // trip_id -> {trip_id, route_id, ...}

        /* --- UI refs --- */
        const startSelect = document.getElementById('startSelect');
        const endSelect = document.getElementById('endSelect');
        const startText = document.getElementById('startText');
        const endText = document.getElementById('endText');
        const loadCsvBtn = document.getElementById('loadCsvBtn');
        const getRouteBtn = document.getElementById('getRouteBtn');
        const clearRouteBtn = document.getElementById('clearRouteBtn');
        const directionInfo = document.getElementById('directionInfo');

        /* Populate dropdowns from stopsList */
        function populateStopSelects() {
            startSelect.innerHTML = ''; endSelect.innerHTML = '';
            const optClick = document.createElement('option');
            optClick.value = ''; optClick.textContent = '-- choose or leave blank to use text input --';
            startSelect.appendChild(optClick.cloneNode(true));
            endSelect.appendChild(optClick.cloneNode(true));
            for (const s of stopsList) {
                const label = `${s.stop_name} (${s.stop_id})`;
                const o1 = document.createElement('option'); o1.value = s.stop_id; o1.textContent = label;
                const o2 = o1.cloneNode(true);
                startSelect.appendChild(o1); endSelect.appendChild(o2);
            }
        }

        /* Find stop by id exact or by substring name (case-insensitive) */
        function findStop(query) {
            if (!query) return null;
            query = query.trim();
            if (stops[query]) return stops[query];
            const q = query.toLowerCase();
            for (const s of stopsList) {
                if (s.stop_name && s.stop_name.toLowerCase().includes(q)) return s;
            }
            return null;
        }

        /* Find a trip that contains both originId and finalId and return sub-sequence of stop_ids in order */
        function findTripSequence(originId, finalId) {
            for (const tripId in stopTimesByTrip) {
                const seq = stopTimesByTrip[tripId].slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
                let idxO = -1, idxF = -1;
                for (let i = 0; i < seq.length; i++) {
                    if (seq[i].stop_id === originId) idxO = i;
                    if (seq[i].stop_id === finalId) { idxF = i; break; }
                }
                if (idxO >= 0 && idxF >= idxO) {
                    const out = [];
                    for (let i = idxO; i <= idxF; i++) {
                        const s = stops[seq[i].stop_id];
                        if (!s) { out.length = 0; break; }
                        out.push(s);
                    }
                    if (out.length) return out;
                }
            }
            return null;
        }

        /* Clear previously drawn route */
        function clearDrawn() {
            if (drawn.poly) { map.removeLayer(drawn.poly); drawn.poly = null; }
            drawn.markers.forEach(m => map.removeLayer(m)); drawn.markers = [];
            directionInfo.innerHTML = '';
        }

        /* Draw sequence of stops: markers + polyline */
        function drawStopsSequence(seq) {
            clearDrawn();
            const latlngs = seq.map(s => [s.lat, s.lon]);
            drawn.poly = L.polyline(latlngs, { color: '#1f78b4', weight: 4 }).addTo(map);
            for (let i = 0; i < seq.length; i++) {
                const s = seq[i];
                const m = L.marker([s.lat, s.lon]).addTo(map).bindPopup(`${i === 0 ? 'Origin' : (i === seq.length - 1 ? 'Final' : 'Stop')}: ${s.stop_name} <br/>ID: ${s.stop_id}`);
                drawn.markers.push(m);
            }
            map.fitBounds(drawn.poly.getBounds(), { padding: [20, 20] });
            directionInfo.innerHTML = `Stops in route: ${seq.length}.`;
        }

        /* Attempt to compute route from selected inputs */
        function computeRoute() {
            const originId = startSelect.value || null;
            const endId = endSelect.value || null;
            let origin = null, final = null;

            if (originId) origin = stops[originId];
            if (endId) final = stops[endId];

            if (!origin) origin = findStop(startText.value);
            if (!final) final = findStop(endText.value);

            if (!origin || !final) {
                alert('Could not resolve both origin and final stops. Make sure CSVs loaded and inputs are correct.');
                return;
            }
            if (origin.stop_id === final.stop_id) { alert('Origin and final are the same stop.'); return; }

            const seq = findTripSequence(origin.stop_id, final.stop_id);
            if (!seq) {
                alert('No trip found that contains both stops in order. Showing direct connection instead.');
                drawStopsSequence([origin, final]);
                return;
            }
            drawStopsSequence(seq);
        }

        /* Load CSVs and build data structures */
        async function loadGTFS() {
            clearDrawn();
            directionInfo.innerHTML = 'Loading CSVs...';
            const base = './csv_files/';
            try {
                const [stopsRows, tripsRows, stopTimesRows] = await Promise.all([
                    fetchCSV(base + 'stops.csv'),
                    fetchCSV(base + 'trips.csv').catch(() => null),
                    fetchCSV(base + 'stop_times.csv')
                ]);

                stopsList.length = 0;
                for (const k in stops) delete stops[k];
                if (!stopsRows || stopsRows.length < 2) throw new Error('stops.csv missing or empty');
                const hdrStops = stopsRows[0].map(h => h.trim());
                const i_id = hdrStops.indexOf('stop_id'), i_name = hdrStops.indexOf('stop_name'), i_lat = hdrStops.indexOf('stop_lat'), i_lon = hdrStops.indexOf('stop_lon');
                for (let i = 1; i < stopsRows.length; i++) {
                    const r = stopsRows[i];
                    if (!r) continue;
                    const id = (i_id >= 0 && i_id < r.length) ? r[i_id].trim() : null;
                    const name = (i_name >= 0 && i_name < r.length) ? r[i_name].trim() : id;
                    const lat = (i_lat >= 0 && i_lat < r.length) ? parseFloat(r[i_lat]) : NaN;
                    const lon = (i_lon >= 0 && i_lon < r.length) ? parseFloat(r[i_lon]) : NaN;
                    if (!id || isNaN(lat) || isNaN(lon)) continue;
                    const obj = { stop_id: id, stop_name: name, lat: lat, lon: lon };
                    stops[id] = obj; stopsList.push(obj);
                }

                for (const k in stopTimesByTrip) delete stopTimesByTrip[k];
                if (stopTimesRows && stopTimesRows.length >= 2) {
                    const hdr = stopTimesRows[0].map(h => h.trim());
                    const i_trip = hdr.indexOf('trip_id'), i_stop = hdr.indexOf('stop_id'), i_seq = hdr.indexOf('stop_sequence');
                    for (let i = 1; i < stopTimesRows.length; i++) {
                        const r = stopTimesRows[i];
                        if (!r) continue;
                        const tid = (i_trip >= 0 && i_trip < r.length) ? r[i_trip].trim() : null;
                        const sid = (i_stop >= 0 && i_stop < r.length) ? r[i_stop].trim() : null;
                        const seq = (i_seq >= 0 && i_seq < r.length) ? parseInt(r[i_seq], 10) : i;
                        if (!tid || !sid) continue;
                        stopTimesByTrip[tid] = stopTimesByTrip[tid] || [];
                        stopTimesByTrip[tid].push({ stop_id: sid, stop_sequence: seq });
                    }
                }

                populateStopSelects();
                directionInfo.innerHTML = `Loaded stops: ${stopsList.length}, trips (stop_times groups): ${Object.keys(stopTimesByTrip).length}`;
            } catch (err) {
                console.error(err);
                alert('CSV load failed: ' + err.message);
                directionInfo.innerHTML = 'CSV load failed';
            }
        }

        /* --- UI wiring --- */
        loadCsvBtn.addEventListener('click', () => loadGTFS());
        getRouteBtn.addEventListener('click', () => computeRoute());
        clearRouteBtn.addEventListener('click', () => clearDrawn());

        /* initial load on open */
        loadGTFS();

        /* --- Fetch and display gec2025.c source (served from parent directory) --- */
        const cpre = document.getElementById('csource');
        const reloadCBtn = document.getElementById('reloadCBtn');
        const toggleCBtn = document.getElementById('toggleCBtn');

        async function loadCSource() {
            cpre.textContent = 'Loading...';
            try {
                const res = await fetch('../gec2025.c');
                if (!res.ok) throw new Error('Fetch failed: ' + res.status);
                const txt = await res.text();
                cpre.textContent = txt;
            } catch (err) {
                cpre.textContent = 'Failed to load gec2025.c: ' + err.message + '\n\nEnsure the server serves the project root (parent of docs/) so ../gec2025.c is accessible.';
            }
        }

        reloadCBtn.addEventListener('click', loadCSource);
        toggleCBtn.addEventListener('click', () => {
            const d = document.getElementById('cDetails');
            d.open = !d.open;
        });
        loadCSource();

    </script>
</body>

</html>